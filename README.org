* Bridje

Bridje is a statically typed LISP, drawing inspiration from both Clojure and
Haskell. It currently runs on the Graal JVM, but is fundamentally a hosted
language - the intention being to have it run on the JavaScript ecosystem too
(eventually).

Its main features include:
- Polymorphic records and variants with type-checked keys, similar to Clojure's
  'spec' library
- A monad-less 'effect system' to statically determine an expression's side
  causes and side effects.
- Type-safe macros.

It is currently pre-alpha, and nowhere near finished. What follows below are
ideas for how I imagine the language would work!

** Forms
Bridje has a number of built-in forms, many similar to their Clojure
counterparts. It also has a few additions, particularly regarding the record
data structures, and its effect and typeclass systems.

*** Basic forms

Primitives in Bridje are mostly the same as Clojure:

- Strings: "foo" - encased in double-quotes.
- Bools - ~true~ / ~false~
- 'Int's: ~4~, ~9~ - 64 bits.
- 'Float's: ~5.3~, ~10.5~ - IEEE double-precision.
- 'BigInt's: ~105N~, ~253N~ - arbitrary precision
- 'BigFloat's: ~153.25M~, ~256.68M~ - arbitrary precision

Function application works as in any other LISP - ~(foo param1 param2)~. Parameters
are eagerly evaluated before calling the function.

'If' and 'do' expressions are unsurprising. In an 'if' statement, though,
because Bridje is typed, the two branches must have an equivalent type.

#+BEGIN_SRC clojure
  (if (> x y)
    x
    y)
#+END_SRC

Let and loop/recur behave as in Clojure. Like in Clojure, 'recur' must be called
from the tail position, and no tail-call optimisation is performed elsewhere. If
no ~loop~ block is present, the recur point is assumed to be the containing
function.

#+BEGIN_SRC clojure
  (let [x 4
        y 5]
    (+ x y))

  (loop [x 5
         y 0]
    (if (pos? x)
      (recur (dec x) (+ y x))
      y))
#+END_SRC


*** Naming values, defining functions

We define both values and functions using =def=. We can optionally specify the
type of a value/function explicitly using =::=- it's not required, but it's checked, and
useful as documentation.

#+BEGIN_SRC clojure
  (:: x Int)
  (def x 4)

  ; functions have their name and parameters wrapped in parens

  (:: (say-hi Str) Str)
  (def (say-hi s)
    (str "Hello, " s "!"))
#+END_SRC


*** Collections

Vectors and sets in Bridje are *homogenous*, unlike Clojure's heterogeneous
collections. They are immutable, and can be arbitrarily nested.

#+BEGIN_SRC clojure
  [1 4 3]
  #{["foo" "bar"] ["baz"]}
#+END_SRC

Bridje does have homogenous maps, but they do not have a specific syntax - they
are constructed from sequences of tuples.

*** Records
In a similar manner to Clojure's 'spec', we define the type of a key, then any
value of that key, throughout the program, is guaranteed to have the same type.
We define keys using =::=:

#+BEGIN_SRC clojure
  (:: :id Int)
  (:: :text Str)
  (:: :a-big-number BigInt)

  (def foo
    {:text "Hello"
     :a-big-number 52N})
#+END_SRC

As in Clojure, we can destructure records, although the syntax is quite
different. In particular, in the long-hand form, the destructuring matches the
structure of the record itself. Here are some examples:

#+BEGIN_SRC clojure
  ;; long-hand - we bind the symbol 'the-id' to the value of ':id' in the record
  (let [{:id the-id} {:id 4}]
    ; the-id = 4
    )

  ;; if the bound symbol matches the key, we don't have to specify it twice - the
  ;; symbol suffices (commas are considered whitespace):
  (let [{username, :id user-id} {:username "jarohen", :id 451}]
    ; username = "jarohen"
    ; user-id = 451
    )

  ;; we can bind the entire data structure by prefixing the symbol with `&`
  (let [{username &user} {:username "jarohen", :id 451}]
    ; username = "jarohen"
    ; user = {:username "jarohen", :id 451}
    )
#+END_SRC


Records can also be nested. Drawing inspiration from hints in Rich Hickey's
'Maybe Not' talk, we do not specify ahead of time what keys a record type
contains, only that it is a record. When the record is used, the type system
then decides which keys the user of the record requires at that particular site.

#+BEGIN_SRC clojure
  (:: :user-id Int)
  (:: :name Str)
  (:: :follower-count Int)

  ;; we don't specify any keys, just that :user is a record
  (:: :user {})

  ;; the type of `say-hi` is (Fn [{:name}] Str)
  ;; - a function from a record containing a `:name` key to a string
  (def (say-hi user)
    (format "Hi, %s!" (:name user)))


  ;; we can also nest the destructuring. N.B. whereas Clojure's destructuring
  ;; syntax is 'inside-out', Bridje's more closely matches the structure of the
  ;; input data

  (let [{:user {:follower-count followers}} {:user {:follower-count 4424}}]
    ; followers = 4424
    )

  (let [{:user {follower-count}} {:user {:follower-count 4424}}]
    ; follower-count = 4424
    )

#+END_SRC

We can define type aliases for common sets of keys:

#+BEGIN_SRC clojure
  (:: BaseUser {:user-id :name})

  (:: (say-hi BaseUser) Str)
#+END_SRC

*** Variants ('union'/'sum' types)

In addition to records, with a set of keys, Bridje also allows developers to
declare 'variants' - a data structure that has /one/ of a possible set of keys.
Variant keys are distinguished from record keys by using an initial capital
letter:

#+BEGIN_SRC clojure
  (:: :Int Int)
  (:: :String Str)
  (:: :Neither) ; variants don't *need* a value, necessarily

  ;; we then construct instances of these variants using the key as a constructor:
  ;; this is of type `[(+ :Int :String :Neither)]` - a vector whose elements either have an
  ;; `:Int` key, a `:String` key, or the value `:Neither`
  (def ints-and-strings
    [(:Int 4) :Neither (:String "hello")])


  ;; we can deconstruct variants using a `case` expression (destructuring if need be).
  ;; in a similar vein to the `if` expression, all of the possible outputs of a
  ;; case expression must have the same type.

  (case (first ints-and-strings)
    (:Int an-int) (+ an-int 2)
    (:String a-string) (count a-string)
    :Neither 0)

  ;; again, we can define type aliases for common variants:
  (:: IntOrString (+ :Int :String :Neither))
#+END_SRC

*** Macros

Bridje macros aim to operate as similar to Clojure's macros as possible -
however, without a heterogeneous list type, we need another way of expressing
and manipulating forms.

Instead, we use variants - a macro is then a function that accepts a number of
Forms, and returns a Form.

#+BEGIN_SRC clojure
  (:: :StringForm Str)
  (:: :IntForm Int)
  (:: :ListForm [Form])
  (:: :VectorForm [Form])
  ;; ...

  (:: Form (+ :StringForm :IntForm :ListForm :VectorForm ...))

  (defmacro (my-first-macro form)
    (case form
      (:StringForm str) (:StringForm "sneaky!")
      form))

  ;; fortunately, syntax-quoting/unquoting translates into Form-generating code as
  ;; you'd expect so, most of the time, Bridje macros will have similar implementations.

  (defmacro (if-not pred then else)
    `(if ~pred
       ~else
       ~then))
#+END_SRC

*** TODO Interop

#+BEGIN_SRC clojure
  (ns my-ns
    {imports {Runtime (java java.lang.Runtime
                       (:: (getRuntime) Runtime)
                       (:: (.freeMemory Runtime) Int))}})

  (Runtime/.freeMemory (Runtime/getRuntime))
#+END_SRC

*** TODO Uncaught exceptions

*** Effects

One of Bridje's main features is its effect system - a way of knowing at
compile-time what side causes/side effects.

We use the example of a simple logging system, where we want to log to stdout.
In Bridje, we declare an effectful function using ~defx~ along with a default
implementation, which may in turn call lower-level effects.

#+BEGIN_SRC clojure
  (:: (print! Str) Void)
  (:: (read-line!) Str)

  (defx (print! s)
    ; interop
    )

  (defx (read-line!)
    ; interop
    )

  (def (println! s)
    (print! (str s "\n")))


  (:: :Debug)
  (:: :Info)
  (:: :Warn)
  (:: :Error)

  (:: Level (+ :Debug :Info :Warn :Error))


  (:: (log! Level Str) Void)

  (defx (log! level s)
    (print! (format "Log [%s]: %s" (pr-str level) s)))

  (def (my-fn x y)
    (log! :Debug (format "Got x: %d, y: %d" x y))
    (+ x y))
#+END_SRC

Effects propagate through the call stack - in this case, the ~println!~ function
is determined to use the ~print!~ effect. The ~my-fn~ function is determined
to use the ~log!~ effect, but not ~print!~ (because default implementations
can be overridden).

We can provide/override implementations of effects using the ~with-fx~
expression. This defines the behaviour of the effect in the /lexical/ scope of
the block.

#+BEGIN_SRC clojure
  (with-fx [(def (print! s)
              ...)]

    (log! Info "Hello!"))
#+END_SRC

=with-fx= introduces a non-trivial overhead to swap out the implementation (in
order to make the default implementations faster) - it is advisable not to use
this in performance-critical code.

There is one 'base' effect, =IO=, which interacts with the outside world. This
is built-in and cannot be explicitly handled.

**** TODO internal mutable state

*** TODO Typeclasses

#+BEGIN_SRC clojure
  (defunion Ordering
    LT EQ GT)

  (defclass (Ord a)
    (:: (compare a a) Ordering))

  (definstance (Ord Int)
    (def (compare x y)
      (cond
        (< x y) LT
        (= x y) EQ
        GT)))
#+END_SRC

#+BEGIN_SRC clojure
  (defunion (Maybe a)
    (Just a)
    Nothing)

  (defclass (Functor f)
    (:: (fmap (f a) (Fn [a] b))
        (f b)))

  (definstance (Functor Maybe)
    (def (fmap maybe)
      (case maybe
        (Just a) (Just (f a))
        Nothing)))

  (defclass #{(Functor m)} (Monad m)
    (:: (return a) (m a))

    (:: (bind (m a) (Fn [a] (m b)))
        (m b)))

  (definstance (Monad Maybe)
    (def (return a)
      (Just a))

    (def (bind maybe f)
      (case maybe
        (Just a) (f a)
        Nothing)))
#+END_SRC

** TODO Namespaces

#+BEGIN_SRC clojure
  (ns myapp.main
    {refers {myapp.users #{get-user! update-user! User}}
     aliases {u myapp.users}})
#+END_SRC

**** TODO
- cycles between vars allowed (with forward declarations)
- immutable namespaces - invalidation + reloading
- cycles including macros?

* LICENCE

Licence tbc. For now, all rights reserved. Feel free to have a browse, though.
