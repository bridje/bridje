(:: double (Fn Int Int))

(def (double x)
  (+ x x))

(:: treble (Fn Int Int))
(def (treble x)
  (+ x (double x)))

;; Env1 stores dependency from 'treble' to 'double'

(def (double x)
  (* x x))

;; Env2 checks type of 'double' against previous type - 'soft' invalidates all dependents

(treble 4)

;; REPL (before eval) realises that treble is soft invalidated - creates Env3 with revalidated 'treble'

;; If I now were to run (treble 4) explicitly using Env1, I'd get the previous behaviour.
;; Run explicitly against env2, it's marked invalid (and always was), so will fail immediately

;; option to reload all invalidated?
;; option to reload all against changed source files?
