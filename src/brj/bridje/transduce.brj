;; seqs

(defrec
  (defclass (Seqable s)
    (:: (seq (s a)) (Seq a)))

  (defadt (Seq a)
    (:: #{(Seqable s)}
        (Cons a (s a)) (Seq a))
    Nil))

(definstance (Seqable Seq)
  (fn (seq c) c))

;; clj
(require '[clojure.walk :as w])

(defbrj vec-seq
  (fn [v]
    (if-not (empty? v)
      (Cons. (first v) (subvec v 1))
      Nil.)))

(defbrj set-seq
  (fn [s]
    (if-not (empty? s)
      (Cons. (first s) (disj s (first s)))
      Nil.)))

;; brj

(defclj {c bridje.kernel.clj-collections}
  (:: (c/vector-seq [a]) (Seq a))
  (:: (c/set-seq #{a}) (Seq a)))

(definstance (Seqable [])
  (fn (seq v) (c/vector-seq v)))

(definstance (Seqable #{})
  (fn (seq s) (c/set-seq s)))


(defadt (LazySeq a)
  (:: #{(Seqable s)}
      (LazySeq (Fn () (s a)))))

(defmacro (lazy-seq coll)
  `(LazySeq (fn (_) ~coll)))

(definstance (Seqable LazySeq)
  (fn (seq (LazySeq f))
    (seq (f))))

(def (lazy-cat seqs)
  (lazy-seq
    (if-seq ((Cons first-seq more-seqs) seqs)
      (if-seq ((Cons first-el more-els) first-seq)
        (Cons first-el (lazy-cat (Cons more-els more-seqs)))
        (lazy-cat more-seqs))

      Nil)))


;; comp
(defclass (Compose c)
  (:: (comp2 (c y z) (c x y)) (c x z)))

(defmacro (comp &forms)
  (if-seq ((Cons f1 more-forms) &forms)
    (if-not (empty? more-forms)
      `(comp2 ~f1 (comp ~@more-forms))
      f1)

    (throw "No forms passed to `comp`")))

;; functors/monads/etc

(defclass (Functor f)
  (:: (fmap (f a) (Fn (a) b)) (f b)))

(defclass #{(Functor m)} (Monad m)
  (:: (return a) (m a))
  (:: (bind (m a) (Fn (a) (m b))) (m b)))

(defadt (Maybe a)
  (Just a)
  Nothing)

(definstance (Functor Maybe)
  (fn (fmap x f)
    (case x
      (Just v) (Just (f e))
      Nothing Nothing)))

(definstance (Monad Maybe)
  (fn (return a)
    (Just a))

  (fn (bind x f)
    (case x
      (Just v) (f v)
      Nothing Nothing)))

(defclass (Monoid a)
  (:: (mzero) a)
  (:: (mplus2 a a) a))

(defmacro (mplus &forms)
  ...)

(definstance #{(Monoid a)} (Monoid (Maybe a))
  (fn (mzero) Nothing)
  (fn (mplus2 x y)
    (cond
      (= x Nothing) y
      (= y Nothing) x
      (let ((Just x) x
            (Just y) y)
        (Just (mplus2 x y))))))

(defclass (Eq a)
  (:: (= a a) Bool))

(:: #{(Eq a)} (not= a a) Bool)
(def (not= a b)
  (not (= a b)))

(definstance (Functor [])
  (fn (fmap v f)
    (transduce v (map f) (->vec))))

(defadt (Tree a)
  (Node (Tree a) a (Tree a))
  Leaf)


;; onto actual transducers

(:: #{(Seqable s)}
    (reduce (s a) (Reducer a b)) b)


(defadt (Reducer x a)
  (Reducer (Fn (x) Unit) ; step
           (Fn () Bool) ; more?
           (Fn () a) ; complete
           ))

(defadt (Transducer x a)
  (Transducer (∀ #{(Seqable s)} (Fn (x) (s a))) ; step
              (Fn () Bool) ; more?
              (∀ #{(Seqable s)} (Fn () (s a))) ; complete
              ))

(def (step-transducer step)
  (Transducer step (fn (more?) true) (fn (complete) Nil)))

(def (map f)
  (step-transducer (fn (step el)
                     (Cons (f el) Nil))))

(def (filter f)
  (step-transducer (fn (step el)
                     (if (f el)
                       (Cons el Nil)
                       Nil))))

(:: (mapcat (∀ #{(Seqable s)} (Fn (x) (s a))))
    (Transducer x a))

(def (mapcat f)
  (step-transducer f))

(def (->vec)
  (let ((!vec (volatile! (transient-vec! []))))
    (Reducer (fn (step el)
               (swap! !vec conj! el)
               Unit)
             (fn (more?) true)
             (fn (complete)
               (persistent! @!vec)))))

(def (take n)
  (let ((!n (volatile! n)))
    (Transducer (fn (step el)
                  (swap! !n dec)
                  (Cons el Nil))

                (fn (more?)
                  (pos? @!n))

                (fn (complete)
                  Nil))))

(def (drop n)
  (let ((!n (volatile! n)))
    (easy-transducer (fn (step el)
                       (if (pos? @!n)
                         (do
                           (swap! !n dec)
                           Nil)

                         (Cons el Nil))))))

(:: (reducer (Transducer a b) (Reducer b c)) (Reducer a c))

(def (reducer (Transducer t-step t-more? t-complete) (Reducer r-step r-more? r-complete))
  (letfn ((fn (handle-els els)
            (loop ((els els))
              (if (r-more?)
                (if-seq ((Seq el more-els) els)
                  (do (r-step el) (recur more-els))
                  Unit)
                Unit))))

    (Reducer (fn (step el)
               (when (r-more?)
                 (handle-els (t-step el))))

             (fn (more?)
               (and (t-more?) (r-more?)))

             (fn (complete)
               (when (r-more?)
                 (handle-els (t-complete)))
               (r-complete)))))

(:: #{(Seqable s)} (reduce* (s a) (Reducer a b)) b)

(def (reduce* coll (Reducer step more? complete))
  (loop ((coll coll))
    (if-seq ((Cons head tail) coll)
      (do
        (step head)
        (if (more?)
          (recur tail)
          (complete)))

      (complete))))

(defmacro (reduce coll &forms)
  `(reduce* ~coll
            ~(if-seq ((Cons r ts) (reverse &forms))
               (if-not (empty? ts)
                 `(reducer (comp ~@ts) ~r)
                 r)

               (throw "No reducer passed to `reduce`"))))


(:: #{(Seqable s)}
    (stream* (s a) (Transducer a b))
    (LazySeq b))

(def (stream* coll t)
  (let (((Transducer step more? complete) t))
    (lazy-seq
      (if-seq ((Cons head tail) (if (more?) coll Nil))
        (lazy-cat (Cons (step head) (Cons (stream* tail t) Nil)))
        (complete)))))

(defmacro (stream coll &forms)
  `(stream* ~coll (comp ~@(reverse forms))))

(definstance (Compose Transducer)
  (fn (comp2 l (Transducer rstep rmore? rcomplete))
    (let ((Transducer lstep lmore? lcomplete) l
          l-no-complete (Transducer lstep lmore? (fn (complete) Nil)))

      (Transducer (fn (step el)
                    (stream* (rstep el) l-no-complete))

                  (fn (more?)
                    (and (rmore?) (lmore?)))

                  (fn (complete)
                    (stream* (rcomplete) l))))))
