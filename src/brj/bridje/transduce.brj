(defadt (Result a)
  (Zero Bool)
  (One a Bool)

  (∀ #{(Seqable s)}
   (Many (s a) Bool)))

(defadt (Reducer x a)
  (Reducer (Fn (x) Bool)
           (Fn () a)))

(defadt (Transducer x a)
  (Transducer (Fn (x) (Result a))
              (Fn () (Result a))))

(def tx0 (Zero true))
(def tx1 (->% (One true)))
(def tx* (->% (Many true)))

(defclass (Monoid m)
  (:: (mzero) (m a))
  (:: (mplus (m a) (m a)) (m a)))

(do
  (defclass (Seqable s)
    (:: (seq (s e)) (Maybe (Seq e))))

  (defadt (Seq e)
    (Seq e (∀ #{(Seqable s)} (s e)))))

(defclass (Functor f)
  (:: (fmap (f a) (Fn (a) b)) (f b)))

(defclass #{(Functor m)} (Monad m)
  (:: (return a) (m a))
  (:: (bind (m a) (Fn (a) (m b))) (m b)))

(defadt (Maybe a)
  (Just a)
  Nothing)

(definstance (Functor Maybe)
  (fn (fmap x f)
    (case x
      (Just v) (Just (f e))
      Nothing Nothing)))

(definstance (Monad Maybe)
  (fn (return a)
    (Just a))

  (fn (bind x f)
    (case x
      (Just v) (f v)
      Nothing Nothing)))

(definstance (Monoid Maybe)
  (fn (mzero) Nothing)
  (fn (mplus x y)
    (case x
      (Just _) y
      Nothing Nothing)))

(defclass (Eq a)
  (:: (= a a) Bool))

(:: #{(Eq a)} (not= a a) Bool)
(def (not= a b)
  (not (= a b)))

(definstance (Functor [])
  (fn (fmap v f)
    (transduce v (map f) (->vec))))

(defadt (Tree a)
  (Node (Tree a) a (Tree a))
  Leaf)

(defadt (Cons a)
  (∀ #{(Seqable s)} (Cons a (s a)))
  Nil)

(defclj {c bridje.kernel.clj-collections}
  (:: (c/vector-seq [a]) (Maybe (Seq [] a)))
  (:: (c/set-seq #{}) (Maybe (Seq #{} a))))

(definstance (Seqable [])
  (fn (seq v) (c/vector-seq v)))

(definstance (Seqable #{})
  (fn (seq s) (c/set-seq s)))

;; clj
(require '[clojure.walk :as w])

(defn ->ADT [env sym & params]
  )

(defbrj vec-seq
  (fn [v]
    (if-not (empty? v)
      (Just. (Seq. (first v) (subvec v 1)))
      Nothing.)))

(defbrj set-seq
  (fn [s]
    (if-not (empty? s)
      (Just. (Seq. (first s) (disj s (first s))))
      Nothing.)))

(definstance (Seqable Cons)
  (fn (seq c)
    (case c
      (Cons e c) (Just (Seq e c))
      Nil Nothing)))

(:: #{(Seqable s)}
    (reduce (s a) (Reducer a b)) b)

(def (reduce coll (Reducer step complete))
  (loop ((coll coll))
    (if-let ((Seq head tail) (seq coll)
             _ (step head))
      (recur tail)
      (complete))))

(:: (tf-chain (Transducer a b) (Transducer b c)) (Transducer a c))

(def (reduced r)
  (case r
    (Zero _) (Zero false)
    (One el _) (One el false)
    (Many els _) (Many els false)))

(definstance (Monad Result)
  (fn (return x)
    (One x true))

  (fn (bind x f)
    (case x
      (Zero cont?) x
      (One cont? el) (-> (f el)
                         (cond-> (not cont?) reduced))
      (Many cont? els) (-> ))))

(defadt (LazySeq a)
  (∀ #{(Seqable s)}
   (LazySeq (Fn () (s a)))))

(definstance (Seqable LazySeq)
  (fn (seq (LazySeq f))
    (seq (f))))

(def (tf-chain (Transducer l-step l-complete) (Transducer r-step r-complete))
  (Transducer (fn (step el)
                (case (l-step el)
                  (Zero cont?) (Zero cont?)
                  (One cont? el)
                  (Many cont? els)
                  ))
              (fn (complete)
                (l-complete)
                (r-complete))))

(:: (reducer (Transducer a b) (Reducer b c)) (Reducer a c))

(def (reducer (Transducer tf-step tf-complete) (Reducer rf-step rf-complete))
  (Reducer ))
