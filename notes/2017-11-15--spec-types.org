* Spec types?
ok, so we have a concept of attributes, and a concept of datatypes (maybe?)
tbh, the name of the type shouldn't really depend on where it's defined - we'd like to move definitions without changing the data

mutually recursive types?
parameterised types?

#+BEGIN_SRC clojure
  (defrec
    (defdata User
      {:id UUID
       :username String})

    (defdata Store
      {:id UUID
       :key {:req #{:User.id :Store.id}}
       :label String})

    (defdata (Maybe a)
      (Just a)
      Nothing)

    (defdata (Tree a)
      (Node {:req {:left (Tree a)
                   :right (Tree a)}})

      (Leaf a)))

  (:james/Store.key store)

  (:james/Node.left tree)

  (Node {:left (Leaf 5)
         :right (Node {:left (Leaf 10)
                       :right (Leaf 20)})})

  (:james/Just.0 my-just)
#+END_SRC

- what's the type of Type?

#+BEGIN_SRC clojure
  (defdata Attribute
    (Attribute {:req {:sym Symbol
                      :required? Bool}}))

  (defrec
    (defdata Type
      Int
      Float
      BigInt
      BigFloat
      String
      Bool
      (Vector Type)
      (Set Type)
      (Fn [Type] Type)
      (AttributeType Attribute)
      (Record {:opt {:req (Set Attribute)
                     :opt (Set Attribute)}})

      (TypeVar String)
      (AppliedType Symbol [Type])))
#+END_SRC

- what about the type of =:james/Store.label= (for example).
  - we'd make two functions - one for req and one for opt: =:?james/Store.label=

- in the kernel lang?
  - I suspect we still have both - because we're adding the optional version at the form level
  - do we just wrap it up and not type-check it?
  - does that mean we can keep =nil= out of the kernel lang?
    - just need to deal with it on interop, then possibly :)

- we'd also like to look up the type of an attribute at runtime, if possible
  - so we'd probably want a =(Fn [Env Attribute] (Maybe Type))= - so we'd need an explicit =Attribute= type.
  - which means we'd want to get that out of an =AttributeForm=, say.
