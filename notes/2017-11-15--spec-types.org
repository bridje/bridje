* Spec types?
** Modelling types
ok, so we have a concept of attributes, and a concept of datatypes (maybe?)
tbh, the name of the type shouldn't really depend on where it's defined - we'd like to move definitions without changing the data

mutually recursive types?
parameterised types?

#+BEGIN_SRC clojure
  (defrec
    (defdata User
      {:id UUID
       :username String})

    (defdata Store
      {:id UUID
       :key #{:User.id :Store.id}
       :label String})

    (defdata (Maybe a)
      (Just a)
      Nothing)

    (defdata (Tree a)
      (Node {:left (Tree a)
             :right (Tree a)
             :val a})
      Leaf))

   (defdata MaybeInt
     (JustInt Int)
     NothingInt)

  (let [maybe (Just 4)]
    (case maybe
      (Just j) j
      Nothing 2))

  (do
    (def (tree-sum tree)
      (case tree
        (Node n) (+ (:Tree.val n)
                    (tree-sum (:Tree.left n))
                    (tree-sum (:Tree.right n)))
        Leaf 0))

    (tree-sum (Node {:Tree.val 4, :Tree.left Leaf, :Tree.right Leaf})))

  (:james/Store.key store)

  (:james/Node.left tree)

  (Node {:left (Leaf 5)
         :right (Node {:left (Leaf 10)
                       :right (Leaf 20)})})

  (:james/Just.0 my-just)
#+END_SRC

what's happening with polymorphic attributes?
shall we keep a separate mapping of what types all the poly attrs should be?
think that's the same as having the ADT mappings
shall we say each polymorphic attribute can only belong to one ADT?
actually, it might be simpler than this
if ADTs own their keys...
can always make a new key that reuses existing keys
and we'll say that each record can only be of one ADT type - trying to extract other keys out is an error
shall we say ADTs can't be extended? if so, they're a different type
the fields within they are still extensible, if they're record types - that's probably powerful enough
implication of this is that ADTs have no base
at this point, they're pretty much a different type...

ok, adts.
what's the point?
totality checking, essentially - union types
polymorphism, also?
so what do we need from a record system that gives us totality and polymorphism? are the two even related?
adt serves as a useful grouping mechanism for polymorphic attributes - i.e. 'these two attributes have the _same_ type'

so, for the polymorphism, we need a group of attributes that vary together
for the totality checking, we need a (possibly polymorphic) value that can be down-cast into a closed set of more specific values
  - let's say we ignored the polymorphic aspect of adts for a mo - just union types - would we do things differently?
  - possibly, although adts do work well as a grouping, and as union types
maybe not even a group - it'd be useful to say that an attribute is of a certain class
  - although, would this be possible? you'd have to instantiate the type, at which point

which means that polymorphic attributes need to be part of a group

- what's the type of Type?

how's about ignoring adts, and just having explicit unions?
polymorphism done on a per-tag basis?

#+BEGIN_SRC clojure
  (defdata (Maybe a)
    (Just a)
    Nothing)

  (defdata User
    {:id Str
     :username Str
     :first-name Str})

  (defdata (Tree a)
    {:left (Tree a)
     :right (Tree a)
     :node a}

    (Node {:Tree.left :Tree.right :Tree.val})
    Leaf)

  (defdata (Either a b)
    (Left a)
    (Right b))
#+END_SRC



#+BEGIN_SRC clojure
  (defdata Attribute
    (Attribute {:sym Symbol
                :required? Bool}))

  (defrec
    (defdata Type
      Int
      Float
      BigInt
      BigFloat
      String
      Bool
      (Vector Type)
      (Set Type)
      (Fn [Type] Type)
      (AttributeType Attribute)
      (Record (Set Attribute))

      (TypeVar String)
      (AppliedType Symbol [Type])))
#+END_SRC

- what about the type of =:james/Store.label= (for example).
  - we'd make two functions - one for req and one for opt: =:?james/Store.label=

- in the kernel lang?
  - I suspect we still have both - because we're adding the optional version at the form level
  - do we just wrap it up and not type-check it?
  - does that mean we can keep =nil= out of the kernel lang?
    - just need to deal with it on interop, then possibly :)

- we'd also like to look up the type of an attribute at runtime, if possible
  - so we'd probably want a =(Fn [Env Attribute] (Maybe Type))= - so we'd need an explicit =Attribute= type.
  - which means we'd want to get that out of an =AttributeForm=, say.

** Modelling effects
Algebraic effects - http://www.eff-lang.org/handlers-tutorial.pdf

#+BEGIN_SRC clojure
  (defdata Ordering
    LT EQ GT)

  ;; (for later) declaring
  (=> (Ord a)
      (:: (sort [a]) [a]))

  ;; declaring effects
  (::! (*read-file* File) String)
  (::! (*write-file* File String) Unit)

  (:: copy-file (Fn [String String] Unit #{io/*read-file* io/*write-file*}))
  ;; shorthand?
  (:: (copy-file String String) Unit #{io/*read-file* io/*write-file*})

  ;; first class type of an effect-fn
  (:: (io/*write-file* File String) Unit #{io/*write-file*})

  ;; first class type of a handler?
  (def my-hdlr
    (hdlr
      (fn (init cb)
        (cb file-map))

      (fn (io/*write-file* file content cb file-map)
        (cb Unit (assoc file-map file-content)))

      (fn (return x file-map)
        (T2 x file-map))))

  (:: my-hdlr (Fn [(Fn [] a #{io/*write-file* ..e})]
                  (T2 a (Map File String))
                  #{IO ..e}))

  (:: (mock-read-file (Map File String)) (Handler #{io/*read-file*} Unit))
  (def (mock-read-file map)
    (hfn
     (fn (io/*read-file* file)
       (...))

     (fn (return _)
       Unit)))

  (hdl (copy "/tmp/src.edn" "/tmp/dest.edn")
       (hdlr
         (fn (init cb)
           (cb a b c))

         (fn (io/*read-file* file cb a b c)
           (cb "hello" a b c))

         (fn (return unit a b c)
           (-))))
#+END_SRC
