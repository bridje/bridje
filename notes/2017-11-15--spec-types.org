* Spec types?
** Modelling types
ok, so we have a concept of attributes, and a concept of datatypes (maybe?)
tbh, the name of the type shouldn't really depend on where it's defined - we'd like to move definitions without changing the data

mutually recursive types?
parameterised types?

#+BEGIN_SRC clojure
  (defrec
    (defattrs User
      {:id UUID
       :username String})

    (defattrs Store
      {:id UUID
       :key #{:User.id :Store.id}
       :label String})

    (defdata (Maybe a)
      (Just a)
      Nothing)

    (defdata (Tree a)
      (Node {:left (Tree a)
             :right (Tree a)})

      (Leaf a)))

  (:james/Store.key store)

  (:james/Node.left tree)

  (Node {:left (Leaf 5)
         :right (Node {:left (Leaf 10)
                       :right (Leaf 20)})})

  (:james/Just.0 my-just)
#+END_SRC

- what's the type of Type?

#+BEGIN_SRC clojure
  (defdata Attribute
    (Attribute {:sym Symbol
                :required? Bool}))

  (defrec
    (defdata Type
      Int
      Float
      BigInt
      BigFloat
      String
      Bool
      (Vector Type)
      (Set Type)
      (Fn [Type] Type)
      (AttributeType Attribute)
      (Record (Set Attribute))

      (TypeVar String)
      (AppliedType Symbol [Type])))
#+END_SRC

- what about the type of =:james/Store.label= (for example).
  - we'd make two functions - one for req and one for opt: =:?james/Store.label=

- in the kernel lang?
  - I suspect we still have both - because we're adding the optional version at the form level
  - do we just wrap it up and not type-check it?
  - does that mean we can keep =nil= out of the kernel lang?
    - just need to deal with it on interop, then possibly :)

- we'd also like to look up the type of an attribute at runtime, if possible
  - so we'd probably want a =(Fn [Env Attribute] (Maybe Type))= - so we'd need an explicit =Attribute= type.
  - which means we'd want to get that out of an =AttributeForm=, say.

** Modelling effects
Algebraic effects - http://www.eff-lang.org/handlers-tutorial.pdf

#+BEGIN_SRC clojure
  (defdata Ordering
    LT EQ GT)

  ;; (for later) declaring
  (=> (Ord a)
      (:: (sort [a]) [a]))

  ;; declaring effects
  (::! (*read-file* File) String)
  (::! (*write-file* File String) Unit)

  (:: copy-file (Fn [String String] Unit #{io/*read-file* io/*write-file*}))
  ;; shorthand?
  (:: (copy-file String String) Unit #{io/*read-file* io/*write-file*})

  ;; first class type of an effect-fn
  (:: (io/*write-file* File String) Unit #{io/*write-file*})

  ;; first class type of a handler?
  (def my-hdlr
    (hdlr
      (fn (init cb)
        (cb file-map))

      (fn (io/*write-file* file content cb file-map)
        (cb Unit (assoc file-map file-content)))

      (fn (return x file-map)
        (T2 x file-map))))

  (:: my-hdlr (Fn [(Fn [] a #{io/*write-file* ..e})]
                  (T2 a (Map File String))
                  #{IO ..e}))

  (:: (mock-read-file (Map File String)) (Handler #{io/*read-file*} Unit))
  (def (mock-read-file map)
    (hfn
     (fn (io/*read-file* file)
       (...))

     (fn (return _)
       Unit)))

  (hdl (copy "/tmp/src.edn" "/tmp/dest.edn")
       (hdlr
         (fn (init cb)
           (cb a b c))

         (fn (io/*read-file* file cb a b c)
           (cb "hello" a b c))

         (fn (return unit a b c)
           (-))))
#+END_SRC
