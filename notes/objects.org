we declare effectful functions using =::=

#+begin_src clojure
  (:: (foo! Int) (! Str))
#+end_src

seqs are going to require polymorphic methods

what do we need?
- it seems that methods are 'just' typeclasses that take the object type as the first param
- can we treat them the same?
- difference may be that, with methods, we can return any implementation we like
  whereas, with typeclasses, the caller decides the implementation of the returned type
- so maybe that's enough of a difference to justify having both concepts - with objects, there's a degree of encapsulation.
- would make it simple for the emission - the caller decides where to get the function from.
- means we need to decide, in the stdlib, whether these things are objects or typeclasses?
- we can use the same functions - the difference is that the type variables in typeclasses apply to the whole signature
- would we want to extend certain other objects? i.e. I want to say that my ConsList is countable, and can hence be passed to anything that accepts count?
- maybe, if it's declared as a method-like signature, we can build the object AoT, and then pass that for functions that just expect something countable?
- the difference is potentially in how many implementations there are for a given function on a different type
  - i.e. 'step' has many implementations from 'a -> Seq b', count likely only has one for a given type
  - who decides how many implementations there might be? choice of declarer, type author, caller, callee
  - callee only cares that there's /at least/ one, caller doesn't particularly care because they know they have one
  - Eq and mzero are good examples where the method one doesn't quite fit
  - essentially, this can also be done with 'static' objects
  - caller doesn't want to have to think about where the implementation is each time, so some degree of this has to be implicit
- with an object, you're only going to be calling the methods on it; with a data type, you might want to destructure it
  - so does this mean that the difference is whether people care about the underlying data type?
  - with objects, I only really care that I can call the methods (with whatever params) - I'm not after access to the underlying data
- with the typeclasses, you're passing a record of functions around
  - particularly, there's no state attached to these - they're referentially transparent
  - no difference between a stateless object and a record of functions?
  - no difference between a typeclass and a record of functions, passed implicitly?
  - so the difference is in the stateful objects
    - and even then, wouldn't be if we cloned the state and got the caller to deal with it
    - difference here is in resources that can't just be cloned
    - transducers (and other non-resource objects), arguably, are closer to stateless objects than they are to resources
    - can we write transducers as stateless objects and get the runtime to transform them into something more performant?
    - that's essentially writing them under ST and getting the runtime to optimise the fuck out of ST
    - and then we just treat resources differently - we understand that they're naturally stateful and just deal with it
- I'm only really creating these objects for the transducing side of things - otherwise I'd have resources?
  - other uses for objects, that aren't either resources or transducers?
  - the need for resources can also be 'mutable state', hence transducers
  - transducers don't seem to be far off 'synchronous actors', though
  - resources - we're probably dealing with java objects anyway
    - that may well be a decent interop opportunity - we treat Java objects the same way as we'd deal with our own
      - we can say 'I don't care what it is, but this object has all the File methods on it'
      - we'll probably want a shorthand for that, e.g. ={File/.*}=
      - that might also be a way to declare our own interop, i.e. how to implement Java interfaces, should we need to (or even be able to, in Graal)
- so normally we talk about focusing on the data, not on the behaviour

#+begin_src clojure
  (:: (. a) (.count a) Int)

  (def (. []) (.count vec)
    (,,,))

  (:: (wants-something-countable {.count}) Int)

  (def (wants-something-countable {.count})
    (count))

  (:: #{(.count a)} (wants-something-countable a) Int)
  (def (wants-something-countable foo)
    (.count foo))

  (:: (returns-something-countable) {.count})
  (def (returns-something-countable)
    {(def (.count)
       42)})

  ;; polymorphic value (m0)
  ;; polymorphic function, polymorphic return (m+)
  ;; polymorphic variant (:Ok)
  ;; polymorphic key?
  ;; polymorphic type-alias
  ;; any of the above accepting polymorphic typealias

  ;; declarations
  (:: a. (.count a) Int)
  (:: a. (.zeros Int) a)
  (:: a. .m0 a)
  (:: a. (.m+ a a) a)
  (:: a. .m1 a)
  (:: a. (.m* a a) a)

  (:: a. (:Cons a (a. Seq)))
  (:: :Nil)
  (:: a. Seq (+ (a. :Cons) :Nil))

  (:: a. b. (.step a) b.Seq)

  (:: a. :Ok a)

  (:: [a] :Ok a)

  (:: (âˆ€ [a] :Ok a))

  ;; there's an object type here too, it's not based on the a, the b, or even the pair
  (:: (.step a) (Seq b))

  ;; a.count for object types?

  (def ([] .) (count vec)
    ...)

  ;; syntax aside, let's see what we need to construct the sugar from
  ;; we could create this initially and then sort the sugar out later

  (:: {:type-vars [a], :sym .count, :type (Fn a Int)})
  (:: {:type-vars [a], :sym .m0, :type a})
  (:: {:type-vars [a], :sym .m+, :type (Fn a a a)})
  (:: {:type-vars [a], :sym :Cons, :params [a (Seq a)]})
  (:: {:type-vars [a], :sym :Nil})
  (:: {:type-vars [a], :sym Seq, :type (+ (:Cons a) :Nil)})
  (:: {:type-vars [a b], :sym .step, :type (Fn a (Seq b))})

  (def {:type-params [[]], :ident .count, :params [vec]}
    )
#+end_src

- I like =(Seq a)=, =(:Cons a)= when we use them - it's like Seq/:Cons are type-level functions that're applied to their type params
- would work for ={(.step Int Int)}= too
- does that mean we should do the same in the overall type declaration?
  - possibly, but we use the parens for function params there too, which I like because it looks like the =def= in the majority of cases
  - the type params are meant to be scoped through the whole type declaration, so just including them in the param part seems wrong
