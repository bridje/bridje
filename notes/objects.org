we declare effectful functions using =::=

#+begin_src clojure
  (:: (foo! Int) (! Str))
#+end_src

seqs are going to require polymorphic methods

what do we need?
- it seems that methods are 'just' typeclasses that take the object type as the first param
- can we treat them the same?
- difference may be that, with methods, we can return any implementation we like
  whereas, with typeclasses, the caller decides the implementation of the returned type
- so maybe that's enough of a difference to justify having both concepts - with objects, there's a degree of encapsulation.
- would make it simple for the emission - the caller decides where to get the function from.
- means we need to decide, in the stdlib, whether these things are objects or typeclasses?
- we can use the same functions - the difference is that the type variables in typeclasses apply to the whole signature
- would we want to extend certain other objects? i.e. I want to say that my ConsList is countable, and can hence be passed to anything that accepts count?
- maybe, if it's declared as a method-like signature, we can build the object AoT, and then pass that for functions that just expect something countable?
- the difference is potentially in how many implementations there are for a given function on a different type
  - i.e. 'step' has many implementations from 'a -> Seq b', count likely only has one for a given type
  - who decides how many implementations there might be? choice of declarer, type author, caller, callee
  - callee only cares that there's /at least/ one, caller doesn't particularly care because they know they have one
  - Eq and mzero are good examples where the method one doesn't quite fit
  - essentially, this can also be done with 'static' objects
  - caller doesn't want to have to think about where the implementation is each time, so some degree of this has to be implicit
- with an object, you're only going to be calling the methods on it; with a data type, you might want to destructure it
  - so does this mean that the difference is whether people care about the underlying data type?
  - with objects, I only really care that I can call the methods (with whatever params) - I'm not after access to the underlying data
- with the typeclasses, you're passing a record of functions around
  - particularly, there's no state attached to these - they're referentially transparent
  - no difference between a stateless object and a record of functions?
  - no difference between a typeclass and a record of functions, passed implicitly?
  - so the difference is in the stateful objects
    - and even then, wouldn't be if we cloned the state and got the caller to deal with it
    - difference here is in resources that can't just be cloned
    - transducers (and other non-resource objects), arguably, are closer to stateless objects than they are to resources
    - can we write transducers as stateless objects and get the runtime to transform them into something more performant?
    - that's essentially writing them under ST and getting the runtime to optimise the fuck out of ST
    - and then we just treat resources differently - we understand that they're naturally stateful and just deal with it
- I'm only really creating these objects for the transducing side of things - otherwise I'd have resources?
  - other uses for objects, that aren't either resources or transducers?
  - the need for resources can also be 'mutable state', hence transducers
  - transducers don't seem to be far off 'synchronous actors', though
  - resources - we're probably dealing with java objects anyway
    - that may well be a decent interop opportunity - we treat Java objects the same way as we'd deal with our own
      - we can say 'I don't care what it is, but this object has all the File methods on it'
      - we'll probably want a shorthand for that, e.g. ={File/.*}=
      - that might also be a way to declare our own interop, i.e. how to implement Java interfaces, should we need to (or even be able to, in Graal)
- so normally we talk about focusing on the data, not on the behaviour

stateless objects under ST, then:
#+begin_src clojure
  (def (take n)
    (obj [n n]
      {(def (.step el)
         (if (pos? n)
           (-> (:More (:Cons el :Nil))
               ($set {n (dec n)}))
           (:Dons (:Cons el :Nil))))}))

  (:: (.step a) (ST (Seq a)))
  (:: (.complete) (ST (Seq b)))

  (:: (reduce->vec [a]
                   {(.step a b)
                    (.?complete b)})
      [b])

  ;; we want something that's going to take in the result type, but also propagate
  (def (reduce->vec vec xf)
    (loop [vec vec
           res []]
      (if-seq [(:Cons el more-els) vec]
        (case (.step xf el)
          (:More coll) (recur more-els (vconcat res coll))
          (:Done coll) (vconcat res coll))

        res)))
#+end_src

- so if we're turning these into ST then we're essentially passing the state, and returning it
- if we want the compiler to turn this into mutable code, then this is borrowing again
- I'm not yet convinced this is worth it - maybe it's time to pull in a bit of Clojure's pragmatism?
- thinking about borrowing, `reduce->vec` mutably borrows `xf`
- we can probably be a little more powerful around borrowing now that we know about how async might work
  - we can guarantee that anything there are only a few ways to spawn new threads
  - and we only need to care about objects, too
  - but that also means anything that can contain objects, remember?
  - can we clone objects across those thread boundaries? efficiently? not if they contain resources, obv
  - alternatively, we could say that you know what you're doing if you share stateful objs between threads, deal with it
  - tbh, if you call object methods, you should know there's the potential to mutate the underlying object
  - if you didn't want that, you'd /actually/ use a record of functions

*ok, no ST, no borrowing :gavel:*

so, types - what're the types of those objects?
- we shouldn't need to care what state the objects carrying, nor give calling code any implicit access to it
- only thing will be, if objects are 'just' records of functions, they should be able to be merged together
- which I guess they can't, they won't have the same state
- if we were doing this as stateful functions that returned their state, we'd have access to it
- or maybe we wouldn't - maybe callers would be forced to generalise over that type

right, so what's the difference between these and typeclass functions?
- typeclass functions are declared over immutable, visible data
- which is how we'd like the objects to behave, ideally
- they'd have a record of state which would be 'returned' in addition to the return value

I know we've said we're not going for borrowing, but
- we're essentially assuming all objects are mutably borrowed
- which means we can't pass them into closures, because those objects are then 'owned' in Rust
- but let's say I do move them
- if I move them into a vector, I can't then use them without moving them out of the vector
- or, presumably, passing a function to the vector that borrows them?
- I can call methods on them if I borrow them - mutable methods if I borrow it mutably; immutable methods if I only borrow it immutably
- do we say we can't make composite types out of objects? i.e. we can only either pass them around or call methods on them?
- let's say we made a record key whose type was an object, would that be useful?
  - the 'system' would benefit from having that, if we were to do that manually
    - (separately, I love the way the system pattern Just Works with normal lifecycle objects now that we have coroutines)
  - way too complex for what we need
  - I guess we like creating/manipulating these data structures much more than a traditional OO lang, which would encapsulate them
- so that's borrowing ruled out, for definite this time, honest.

ST.
- feels like it fits the functional pattern much better.
- if we insist that the state pattern for these objects only carries a single record

(:: (. a b) (.step a) (Seq b))

what's the type of =(take n)= ?

#+begin_src clojure
  (def (take n)
    ;; assume positive n
    (obj {n (dec n)}
      (def (.step el)
        (-> (if (pos? n)
              (:More (:Cons el :Nil))
              (:Done (:Cons el :Nil)))
            (setting {n (dec n)})))))

  (:: (take Int) {(.step a a)})
  (:: (. a b) (.step a) (Seq b))
#+end_src

Haskell has
#+begin_src haskell
  class Monoid a where
    mzero :: a
    mplus :: a -> a -> a
#+end_src

but this doesn't really use the same pattern
in Haskell, step would have one type, or it'd have functional dependencies - the type of the object determines the type of the other params

#+begin_src haskell
  class Mapper o a b | o -> a b where
    step :: a -> State o (Seq b)
    complete :: State o (Seq b)
#+end_src

fuck. so that kinda resets how I'm thinking about objects - that makes them way more like typeclasses

#+begin_src clojure
  (:: (. a b) :Mapper (Fn a b))
  (:: :Taker (Mut Int))

  (:: (. o) (.more? o) Bool)
  (:: (. o -> a b) (.step o a) (Seq b))
  (:: (. o -> b) (.complete o) (Seq b))

  (:: (. a) (.count a) Int)

  (def (. (:Mapper a b)) (.more? _) true)

  (def (. a b (:Mapper a b)) (.step (:Mapper f) el)
    (:Cons (f el) :Nil))

  (def (. a b (:Mapper a b)) (.complete _) :Nil)

  (:: (map (Fn a b)) (:Mapper a b))

  (def (map f)
    (:Mapper f))

  (def (. :Taker) (.more? (:Taker n)) (pos? n))

  (def (. :Taker) (.step (:Taker n) el)
    (set! n (dec n))
    (:Cons el :Nil))

  (def (. :Taker) (.complete _) :Nil)

  (def (take n)
    (:Taker (mut n)))

  (:: (. a) :PartitionAller Int (Mut [a]))

  (def (. (:PartitionAller a)) (.more? _) true)

  (def (. (:PartitionAller a)) (.step (:PartitionAller n coll) el)
    (let [new-coll (conj coll el)]
      (if (= (count new-coll) n)
        (do
          (set! coll [])
          (:Cons new-coll :Nil))

        (do
          (set! coll new-coll)
          :Nil))))

  (def (. (:PartitionAller a)) (.complete (:PartitionAller n coll))
    (if-not (empty? coll)
      (:Cons coll :Nil)
      :Nil))

  (def (partition-all n)
    (:PartitionAller n (mut [])))
#+end_src

wow. yeah, that's it. still not massively happy about the =(. ...)= syntax, but that's a much smaller problem
how does the mutability propagate out?
changed - it's now within the object, it's going to be rare, in performance-critical code, and callers should probably know about it

#+begin_src clojure
  ;; declarations
  (:: (. a) (count a) Int)
  (:: (. a) (zeros Int) a)
  (:: (. a) m0 a)
  (:: (. a) (m+ a a) a)
  (:: (. a) m1 a)
  (:: (. a) (m* a a) a)

  (:: (. a) (:Cons a (Seq a)))
  (:: :Nil)
  (:: (. a) Seq (+ (:Cons a) :Nil))

  (:: (. a) (:Ok a))

  (:: (. o -> a b) (step o a) (Seq b))

  (def (. [a]) (count vec)
    ...)

  (:: #{(count a)} (wants-something-countable a) Str)

  (def (wants-something-countable foo)
    (format "%d element(s) in the list" (count foo)))

  (def (. (:Mapper a b) a b) (step (:Mapper f) el)
    (:Cons (f el) :Nil))

  (:: #{(step o a b) (complete o b)}
      (mapcat-ish o [a]) [b])
#+end_src

- I like =(Seq a)=, =(:Cons a)= when we use them - it's like Seq/:Cons are type-level functions that're applied to their type params
- would work for ={(step Int Int)}= too
- does that mean we should do the same in the overall type declaration?
  - possibly, but we use the parens for function params there too, which I like because it looks like the =def= in the majority of cases
  - the type params are meant to be scoped through the whole type declaration, so just including them in the param part seems wrong

open questions:
- how does interop/'finally' work in these circumstances?
- are we sure we've got all the overlap between polymorphism, effects and rank-n?
  - do we need rank-n yet? biggest use was for transducers
  - GADTs I think are sorted because we separate constructors anyway, but confirm
- not convinced we've yet got the full impact of the spec-like records on the type-system
  - particularly, the 'don't always have to carry all the keys' part

#+begin_src clojure
  (ns foo
    {:imports {RT java.lang.Runtime
               LL java.util.LinkedList}})

  ;; if we were to write the objects in full, in Bridje
  (:: (. a) :add (Fn a Void))
  (:: (. a) (:LL {(:add a)}))
  (:: (LL/new) (:LL a))
  (:: (. o -> a) (ll-add o a) Void)

  (def (. (:LL a) a) (ll-add (:LL {add}) a)
    (add a))

  ;; but that's obviously pretty verbose.
  ;; let's add some sugar:

  (:: (LL/new) (LL a))
  (:: (LL/new.with-coll [a]) (LL a)) ; overloads
  (:: (LL/.add (LL a) a) Void)

  ;; so does that mean we should do the same in Bridje and save ourselves the fuss?
  ;; nah, because in Bridje these are just functions, or they're polys

  ;; having said that, it's quite a neat syntax difference and differentiates between the two quite nicely

  (:: (. o) (.count o) Int)
  (:: (. a) m0 a)


  (:: (. o) (.more? o) Bool)
  (:: (. o a b) (.step o a) (Seq b))
  (:: (. o b) (.complete o) (Seq b))


  (:: (. a b) (:Mapper (Fn a b)))

  (def (. (:Mapper a b)) (.more? _)
    true)

  (def (. (:Mapper a b) a b) (.step (:Mapper f) el)
    (:Cons (f el) :Nil))

  (def (. (:Mapper a b) b) (.complete _)
    :Nil)

  (:: (map (Fn a b)) (:Mapper a b))
  (def (map f)
    (:Mapper f))


  (:: (:Taker (Mut Int)))

  (def (. :Taker) (.more? (:Taker n))
    (pos? n))

  (def (. :Taker a a) (.step (:Taker n) el)
    (-> (:Cons el :Nil)
        (set! (dec n))))

  (def (. :Taker a) (.complete _)
    :Nil)

  (def (take n)
    (:Taker n))


  (:: (. a) (:PartitionAller Int (Mut [a])))

  (def (. (:PartitionAller a)) (.more? _) true)

  (def (. (:PartitionAller a) a [a]) (.step (:PartitionAller n coll) el)
    (let [new-coll (conj coll el)]
      (if (>= (count new-coll) n)
        (-> (:Cons coll :Nil)
            (set! n []))
        (-> :Nil
            (set! n new-coll)))))

  (def (. (:PartitionAller a) [a]) (.complete (:PartitionAller n coll))
    (if-not (empty? coll)
      (-> (:Cons coll :Nil)
          (set! n []))

      :Nil))

  (def (partition-all n)
    (:PartitionAller n []))


  (:: (. a) (:Filter (Fn a Bool)))

  (def (. (:Filter a)) (.more? _) true)

  (def (. (:Filter a) a a) (.step (:Filter p) el)
    (if (p el)
      (:Cons el :Nil)
      :Nil))

  (def (. (:Filter a) a) (.complete _) :Nil)

  (def (filter p)
    (:Filter p))


  ;; so how much of the map syntax do we want to allow?
  ;; we _could_ treat them, near enough, like objects

  (:: (mapcat-ish [a] {(.more? o) (.step o a b) (.complete o b)})
      [b])

  ;; or we could say that they're fancy typeclasses

  (:: #{(.more? o) (.step o a b) (.complete o b)}
      (mapcat-ish [a] o)
      [b])

  ;; this precludes us from returning objects, but does mean that we can express things like
  ;; a function returning a data structure of the same type
#+end_src

we don't want to attach object-like functions to existing types - redefinition would mean that existing objects would not get the new behaviour.
given that, we'll call/type 'methods' exactly like we'd call/type other polymorphic functions, so we want them to look the same too

what about the 'returning something seqable' question?
we can do this pretty much automatically, so long as there's a type signature defined?
but this requires returning a pair, which requires returning an object

#+begin_src clojure
  (:: (. o) (.more? o) Bool)
  (:: (. o a b) (.step o a) [b])
  (:: (. o b) (.complete o) [b])

  (:: #{(.more? o) (.step o a b) (.complete o b)}
      (into-vec [a] o)
      [b])
#+end_src
