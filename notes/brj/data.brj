;; defdata

(defdata (:Tree a)
  {:left (Tree a)
   :node a
   :right (Tree a)}

  (:Node {:left :node :right})
  :Leaf)

(defdata :Address
  {:line1 Str
   :line2 Str
   :city Str
   :region Str
   :postal-code Str}

  (:Address {:line1 :?line2 :city :region :postal-code}))

(defdata {:foo? Bool
          :foo-address :Address})

;; typeclasses

(defclass (Functor f)
  (:: (fmap (f a) (Fn [a] b))
      (f b)))

(definstance (Functor :Maybe)
  (def (fmap maybe f)
    (case maybe
      (:Just a) (:Just (f a))
      _ :Nothing)))

(defclass #{(Functor m)} (Monad m)
  (:: (bind (m a) (Fn [a] (m b))) (m b))
  (:: (return a) (m a)))

(definstance (Monad :Maybe)
  (def (return a)
    (:Just a))

  (def (bind maybe f)
    (case maybe
      (:Just a) (f a)
      _ :Nothing)))

;; namespace

(ns social.bar
  {:alias {u social.user}
   :refer {social.user #{:User :foo?}}})

;; destructuring

(:: (foo {:User. #{:id :?first-name :?last-name :address},
          :u/User. #{}
          :u/ #{:foo?}
          :foo, :foo-address
          & r}) Int)

(def (foo {:User. {id, :?first-name ?prenom, :?last-name ?nom
                   :address (Address {* a}),
                   * user}

           :u/User. {...}

           :social.user/ {...}
           :u/ {foo?}
           foo?,
           :foo-address (:Address {* line1})
           * all-of-it})
  ...)

(foo {:User. {id, :first-name first-name}, :foo? true})
