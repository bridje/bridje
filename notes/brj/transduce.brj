(defdata (:Seq a)
  (:Cons a (:Seq a))
  :Nil)

(defclass (Seqable s)
  (:: (seq (s a)) (:Seq a)))

(definstance (Seqable (:Seq a))
  (def (seq xs) xs))

(defdata (:Transducer a b)
  (:Transducer (Fn [a] (Seqable b))
               (Fn [] Bool)
               (Fn [] (Seqable b))))

(def (mapcat f)
  (:Transducer f (fn [] true) (fn [] :Nil)))

(def (map f)
  (mapcat (#-> f (:Cons :Nil))))

(def (filter f)
  (mapcat (fn [el]
            (if (f el)
              (:Cons el :Nil)
              :Nil))))

;; TODO internal mutable state?
;; TODO reduce
;; TODO whole ns compilation? macros?
;; TODO do we need rank-n types?

(def (partition-all n)
  (lv/with-local-vars
    (let [(!segment (lv/lvar (t/transient-vec [])))]
      (:Transducer (fn [el]
                     (let [(seg (lv/deref! !segment))
                           (seg-len (t/count! seg))]
                       (if (>= n seg-len)
                         (let [(seg (t/persistent! seg))
                               (_ (reset! !segment (t/transient-vec [])))]
                           (:Cons seg :Nil))

                         (lv/let [(seg (t/conj! seg el))
                                  (_ (reset! !segment seg))]
                           :Nil))))

                   (fn [] true)

                   (fn []
                     (let [(seg (deref! !segment))
                           (seg-len (t/count! seg))]

                       (if (pos? seg-len)
                         (:Cons seg :Nil)
                         :Nil)))))))
