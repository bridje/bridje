(defunion (Seq a)
  (Cons a (Seq a))
  Nil)

(defclass (Seqable s)
  (:: (->seq (s a)) (Seq a)))

(definstance (Seqable Seq)
  (def (->seq xs) xs))

(defunion (LazySeq a)
  (LazySeq (Fn [] (Seq a))))

(definstance (Seqable LazySeq)
  (def (->seq f) (f)))

(defmacro (lazy-seq & body)
  `(LazySeq (fn [] ~@body)))

(defunion (Transducer a b)
  (Transducer (Fn [a] (Seqable b))
              (Fn [] Bool)
              (Fn [] (Seqable b))))

(defunion (Reducer a b)
  (Reducer (Fn [a] Void)
           (Fn [] Bool)
           (Fn [] b)))

(def (mapcat f)
  (Transducer f (fn [] true) (fn [] Nil)))

(def (map f)
  (mapcat (->% f (Cons Nil))))

(def (keep f)
  (mapcat (fn [el]
            (case (f el)
              (Just x) (Cons x Nil)
              Nil))))

(def (filter f)
  (mapcat (fn [el]
            (if (f el)
              (Cons el Nil)
              Nil))))

;; TODO internal mutable state?
;; TODO reduce
;; TODO whole ns compilation? macros?
;; TODO do we need rank-n types?

;; what does 'safe mutable state' mean?
;; only one thread accessing?

;; one side - Volatile. accessible from anywhere, unsafe.
;; do we make volatile safer, or do we make State more performant?
;; can we do multiple return in java without allocating an object? is an array quicker to allocate?

(def (take n)
  (let [(!count (lv/lvar n))]
    (Transducer (fn [el] (lv/swap! !count dec) (Cons el Nil))
                (fn [] Nil))))

(def (drop n)
  (let [(!count (lv/lvar n))]
    (Transducer (fn [el]
                  (let [(count (lv/deref! !count))]
                    (if (zero? count)
                      (Cons el Nil)
                      (do
                        (lv/swap! count dec)
                        Nil))))

                (fn [] true)
                (fn [] Nil))))

(def (partition-all n)
  (let [(!segment (lv/lvar (t/transient-vec [])))]
    (Transducer (fn [el]
                  (let [(seg (lv/deref! !segment))
                        (seg-len (t/count! seg))]
                    (if (>= n seg-len)
                      (let [(seg (t/persistent! seg))
                            (_ (reset! !segment (t/transient-vec [])))]
                        (Cons seg Nil))

                      (let [(seg (t/conj! seg el))
                            (_ (reset! !segment seg))]
                        Nil))))

                (fn [] true)

                (fn []
                  (let [(seg (deref! !segment))
                        (seg-len (t/count! seg))]

                    (if (pos? seg-len)
                      (Cons seg Nil)
                      Nil))))))


(:: (reduce* (Seqable a) (Reducer a b)) b)

(def (reduce* xs (Reducer r-step r-more? r-complete) r)
  (if (r-more?)
    (if-seq [((Cons x xs) xs)]
      (do
        (r-step x)
        (recur xs r))

      (r-complete))

    (r-complete)))


(:: (reduce-xfs-2 (Transducer a x) (Reducer x b)) (Reducer a b))

(def (reduce-xfs-2 (Tranducer t-step t-more? t-complete)
                   (Reducer r-step r-more? r-complete))
  (let-rec [(def (pipe xs)
              (if-seq [((Cons x xs) xs)]
                (if (r-more?)
                  (do
                    (r-step x)
                    (recur cs))
                  Void)
                Void))]

    (Reducer (fn [x]
               (pipe (t-step x))
               Void)

             (fn []
               (and (t-more?) (r-more?)))

             (fn []
               (when (r-more?)
                 (pipe (t-complete)))

               (r-complete)))))

(defmacro (reduce-xfs ts r)
  (if-seq [((Cons t ts) ts)]
    `(reduce-xfs2 ~t (reduce-xfs ~@ts ~r))
    r))

(defmacro (xf xs & xfs)
  `(xf* ~xs
        (if-not (empty? xfs)
          `(reduce-xfs ~(butlast xfs) (last xfs))
          (throw "No reducer passed to `reduce`"))))

;; pass two lazy-seqs
(def (lazy-cat2 xs ys)
  (lazy-seq
    (if-seq [((Cons x xs) xs)]
      (Cons x (lazy-cat2 xs ys))
      ys)))

(def (reduce-l xs f init)
  (if-seq [((Cons x xs) xs)]
    (recur xs (f x acc))
    acc))

(def (reduce-r xs f init)
  (reduce-l (reverse xs) f init))

(defmacro (lazy-cat & seqs)
  (if-seq [((Cons sq seqs) seqs)]
    `(lazy-cat2 (lazy-seq ~sq) (lazy-cat ~@seqs))
    `Nil))

(def (t-plus2 (Tranducer l-step l-more? l-complete)
              (Tranducer r-step r-more? r-complete))
  (let-rec [(def (pipe xs)
              (if (r-more?)
                (if-seq [((Cons x xs) xs)]
                  (lazy-cat2 (r-step x) (pipe xs))
                  Nil)
                Nil))]
    (Transducer (fn [el]
                  (pipe (l-step el)))

                (fn []
                  (and (l-more?) (r-more?)))

                (fn []
                  (lazy-cat2 (if (r-more?)
                               (pipe (r-complete))
                               Nil)
                             (r-complete))))))

(defmacro (t-plus t & ts)
  (if-not (empty? ts)
    `(t-plus2 ~t (t-plus ~@ts))
    t))

(def (lazy-xf* xs t)
  (lazy-seq
   (let [((Transducer t-step t-more? t-complete) t)]
     (if t-more?
       (if-seq [((Cons x xs) xs)]
         (lazy-cat (t-step x) (lazy-xf* xs t))
         (t-complete))

       (t-complete)))))

(defmacro (lazy-xf xs & ts)
  (if-seq [((Cons t ts) ts)]
    `(lazy-xf* ~xs (t-plus ~t ~@ts))
    xs))
