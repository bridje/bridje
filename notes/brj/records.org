* After Rich's Conj talk
so, schemas and selections

hard bit is going to be about nested selections. in fact, do we want to specify
collection types within aggregates at all?

we do probably want to specify /within/ those collections - i.e user has many
addresses but we only care about the postal-codes in each one

** Some other ideas
Native imports - end them with a =!= to declare a native effect
Don't /need/ to declare fx in advance, end with =!= and it's implicit
=->?= for =some->=

** Big example

#+BEGIN_SRC clojure
  ;; Type alias
  (:: UserID UUID)

  ;; Simple enum
  (:: :LT)
  (:: :EQ)
  (:: :GT)
  (:: Ord (+ :LT :EQ :GT))

  ;; Simple params, alias
  (:: (:Just a) a)
  (:: :Nothing)
  (:: (Maybe a) (+ (:Just a) :Nothing))

  ;; parameterised types
  (:: (:left-tree a) (Tree a))
  (:: (:node-val a) a)
  (:: (:right-tree a) (Tree a))

  (:: (:Node a) {(:left-tree a) (:node-val a) (:right-tree a)})
  (:: :Leaf)

  (:: (Tree a) (+ (:Node a) :Leaf))

  (:Node {:left-tree :Leaf, :node-val 5, :right-tree :Leaf})

  (type :Node)
  => (Fn [{:left-tree :node-val :right-tree}] (+ (:Node a)))

  ;; Declaring polymorphic function types
  (:: (.eq a) (Fn [a a] Bool))
  (:: (.ord a) (Fn [a a] Ord))

  (:: (.count a) (Fn [a] Int))
  (:: (.sum a) (Fn [a] Int))

  (:: (.return m) (Fn [a] (m a)))

  (:: (.bind m)
      (Fn [(m a) (Fn [a] (m b))]
          (m b)))

  (:: #{(.return m)} (m a))

  ;; behaviour of polymorphic functions for a given type
  (def (.return Maybe) :Just)

  (def (.bind Maybe)
    (fn [maybe f]
      (case maybe
        (:Just x) (f x)
        :Nothing :Nothing)))

  (def (.count (Tree a))
    (fn [tree]
      (case tree
        (:Node {left-tree right-tree}) (+ 1 (tree-count left-tree) (tree-count right-tree))
        :Leaf 0)))

  (:: (.fmap f)
      (Fn [(f a) (Fn [a] b)]
          (f b)))

  (def (.fmap Maybe)
    (fn [maybe f]
      (case maybe
        (:Just x) (:Just (f x))
        :Nothing :Nothing)))

  ;; calling polymorphic functions

  (:: #{(.fmap f)}
      (fmap-caller (f Int)) (f Int))

  (def (fmap-caller foo)
    (.fmap foo inc))
#+END_SRC

** Laziness
laziness could be implemented with 'reducible', might mean that we don't need 'protocols'

#+BEGIN_SRC clojure
  (:: (:More a) a)
  (:: (:Done a) a)

  (:: (:step acc el) (Fn [acc el] (+ (:More acc) (:Done acc))))
  (:: (:init acc) acc)
  (:: (:complete acc) (Fn [acc] res))

  (:: Reducible (Fn [{(:init acc) (:step acc el) (:complete acc res)}] res))

  (:: range Reducible)

  (def (range {step init complete})
    (loop [acc init
           n 0]
      (case (step acc n)
        (:More new-acc) (recur new-acc (inc n))
        (:Done new-acc) (complete new-acc))))

  (def (iterate f x {xf/step xf/init xf/complete})
    (loop [acc init
           el x]
      (case (step acc el)
        (:More new-acc) (recur new-acc (f el))
        (:Done res) (complete res))))

  (def (range {range/?start range/?end range/?step})
    (fn [rf]
      (xf> (iterate (->% (+ (or-> ?step 1))) (or-> ?start 0))
           (take-while (fn [n]
                         (if-let [end ?end]
                           (< n end)
                           true)))
           rf)))

  (def (line-seq path)
    (fn [{xf/step xf/init xf/complete}]
      (let [rdr (open! path)]
        (try
          (loop [acc init]
            (case (read-line! rdr)
              (:Just line) (case (step acc line)
                             (:More new-acc) (recur new-acc)
                             (:Done new-acc) (complete new-acc))
              :Nil (complete acc)))

          (finally
            (close! rdr))))))

  (def xf/>vec
    {:init (transient [])
     :step conj!
     :complete persistent!})

  (-> (line-seq "/home/james/foo.txt")
      (xf> (xf/map (->% (str/split #"\s+")
                        (xf> (xf/filter (->% (= "foo")))
                             xf/count)))
           xf/sum))

  (def xf/sum
    {:init 0, :step +, :complete identity})

  (def xf/count
    (:init 0, :step (fn [acc el] (inc acc)), :complete identity))

  (def xf/mean
    {:init {:mean-sum 0, :mean-count 0}
     :step (fn [{mean-sum mean-count} el]
             {:mean-sum (+ mean-sum el)
              :mean-count (inc mean-count)})
     :complete (fn [{mean-sum mean-count}]
                 (/ mean-sum mean-count))})

  (def (take-while p)
    (fn [el]
      (if (p el)
        (:More (:Cons el :Nil))
        (:Done :Nil))))

  (def (drop-while p)
    (let [drop? (mut/mut true)]
      (fn [el]
        (if (mut/get drop?)
          (if (p el)
            (:More :Nil)
            (do
              (mut/set drop? false)
              (:More (:Cons el :Nil))))

          (:More (:Cons el :Nil))))))

  ((range {}) {:step (fn [acc n]
                       ((if (< n 10) :More :Done) (+ acc n)))
               :init 0
               :complete identity})

  ;; becomes
  (xf> (range {:range/end 10}) xf/sum)
#+END_SRC

difference is that, with lazy seqs, the consumer is in control of the seq.
is this an issue? what can you do?
you can store the partially evaluated seq
you can pause execution
you can zip two lazy sequences together

