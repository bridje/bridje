* After Rich's Conj talk
so, schemas and selections

hard bit is going to be about nested selections. in fact, do we want to specify
collection types within aggregates at all?

we do probably want to specify /within/ those collections - i.e user has many
addresses but we only care about the postal-codes in each one

** Some other ideas
Native imports - end them with a =!= to declare a native effect
Don't /need/ to declare fx in advance, end with =!= and it's implicit
=->?= for =some->=

** Big example

#+BEGIN_SRC clojure
  ;; Type alias
  (:: UserID UUID)

  ;; Simple enum
  (:: :LT)
  (:: :EQ)
  (:: :GT)
  (:: Ord (+ :LT :EQ :GT))

  ;; Simple params, alias
  (:: (:Just a) a)
  (:: :Nothing)
  (:: (Maybe a) (+ (:Just a) :Nothing))

  ;; parameterised types
  (:: (:left-tree a) (Tree a))
  (:: (:node-val a) a)
  (:: (:right-tree a) (Tree a))

  (:: (:Node a) {(:left-tree a) (:node-val a) (:right-tree a)})
  (:: :Leaf)

  (:: (Tree a) (+ (:Node a) :Leaf))

  (:Node {:left-tree :Leaf, :node-val 5, :right-tree :Leaf})

  (type :Node)
  => (Fn [{:left-tree :node-val :right-tree}] (+ (:Node a)))

  ;; Declaring polymorphic function types
  (:: (.eq a) (Fn [a a] Bool))
  (:: (.ord a) (Fn [a a] Ord))

  (:: (.count a) (Fn [a] Int))
  (:: (.sum a) (Fn [a] Int))

  (:: (.return m) (Fn [a] (m a)))

  (:: (.bind m)
      (Fn [(m a) (Fn [a] (m b))]
          (m b)))

  (:: #{(.return m)} (m a))

  ;; behaviour of polymorphic functions for a given type
  (def (.return Maybe) :Just)

  (def (.bind Maybe)
    (fn [maybe f]
      (case maybe
        (:Just x) (f x)
        :Nothing :Nothing)))

  (def (.count (Tree a))
    (fn [tree]
      (case tree
        (:Node {left-tree right-tree}) (+ 1 (tree-count left-tree) (tree-count right-tree))
        :Leaf 0)))

  (:: (.fmap f)
      (Fn [(f a) (Fn [a] b)]
          (f b)))

  (def (.fmap Maybe)
    (fn [maybe f]
      (case maybe
        (:Just x) (:Just (f x))
        :Nothing :Nothing)))

  ;; calling polymorphic functions

  (:: #{(.fmap f)}
      (fmap-caller (f Int)) (f Int))

  (def (fmap-caller foo)
    (.fmap foo inc))
#+END_SRC

** Laziness
laziness could be implemented with 'reducible', might mean that we don't need 'protocols'

#+BEGIN_SRC clojure
  (:: (:More a) a)
  (:: (:Done a) a)

  (:: (:step acc el) (Fn [acc el] (+ (:More acc) (:Done acc))))
  (:: (:init acc) acc)
  (:: (:complete acc) (Fn [acc] res))

  (:: Reducible (Fn [{(:init acc) (:step acc el) (:complete acc res)}] res))

  (:: range Reducible)

  (def (range {step init complete})
    (loop [acc init
           n 0]
      (case (step acc n)
        (:More new-acc) (recur new-acc (inc n))
        (:Done new-acc) (complete new-acc))))

  (def (iterate x f)
    (fn (_ {xf/step xf/init xf/complete})
      (loop [acc init
             el x]
        (case (step acc el)
          (:More new-acc) (recur new-acc (f el))
          (:Done res) (complete res)))))

  (def (range {range/?start range/?end range/?step})
    (fn (_ rf)
      (xf> (iterate (or-> ?start 0) (->% (+ (or-> ?step 1))))
           (take-while (fn [n]
                         (if-let [end ?end]
                           (< n end)
                           true)))
           rf)))

  (def (line-seq path)
    (fn (_ {xf/step xf/init xf/complete})
      (let [rdr (open! path)]
        (try
          (loop [acc init]
            (case (read-line! rdr)
              (:Just line) (case (step acc line)
                             (:More new-acc) (recur new-acc)
                             (:Done new-acc) (complete new-acc))
              :Nil (complete acc)))

          (finally
            (close! rdr))))))

  (def xf/>vec
    {:init (transient [])
     :step conj!
     :complete persistent!})

  (-> (line-seq "/home/james/foo.txt")
      (xf> (xf/map (->% (str/split #"\s+")
                        (xf> (xf/filter (->% (= "foo")))
                             xf/count)))
           xf/sum))

  (def xf/sum
    {:init 0, :step +, :complete identity})

  (def xf/count
    (:init 0, :step (fn [acc el] (inc acc)), :complete identity))

  (def xf/mean
    {:init {:mean-sum 0, :mean-count 0}
     :step (fn [{mean-sum mean-count} el]
             {:mean-sum (+ mean-sum el)
              :mean-count (inc mean-count)})
     :complete (fn [{mean-sum mean-count}]
                 (/ mean-sum mean-count))})

  (def (take-while p)
    (fn [el]
      (if (p el)
        (:More (:Cons el :Nil))
        (:Done :Nil))))

  (def (drop-while p)
    (let [drop? (mut/mut true)]
      (fn (_ el)
        (if (mut/get drop?)
          (if (p el)
            (:More :Nil)
            (do
              (mut/set drop? false)
              (:More (:Cons el :Nil))))

          (:More (:Cons el :Nil))))))

  ((range {}) {:step (fn [acc n]
                       ((if (< n 10) :More :Done) (+ acc n)))
               :init 0
               :complete identity})

  ;; becomes
  (xf> (range {:range/end 10}) xf/sum)
#+END_SRC

difference is that, with lazy seqs, the consumer is in control of the seq.
is this an issue? what can you do?
you can store the partially evaluated seq
you can pause execution
you can zip two lazy sequences together

** TODO Project?
#+BEGIN_SRC clojure
  {:imports {ZDT (java java.time.ZonedDateTime)
             Inst (java java.time.Instant)}}

  ;; users

  (:: UserId UUID)

  (:: {:user-id UserId
       :username Str
       :first-name Str
       :last-name Str
       :created-at Inst

       :user {}})

  ;; posts
  (:: {:post-id UUID
       :created-at Inst
       :title Str})

  (:: :Mention UserId)
  (:: :Hashtag Str)
  (:: :Text Str)

  (:: :content [(+ :Text :Hashtag :Mention)])

  ;; these are a documentation of the keys the map may have, but no more - the actual contents are determined at each site
  (:: :user {:user-id :username :first-name :last-name :created-at :posts})

  (:: UserRegistrationForm {:username :first-name :last-name :marketing-enabled?})

  (:: :posts [{:post}])

  (:: (render-user {:user {:username :first-name :last-name}}))

  (:: FullUser {:user {}})

  (:: :post {:post-id :created-at, {:user {:user-id}}, :title :content})

  (:: Attrs {})
  (:: Children [ReactEl])

  (:: (div Attrs Children) ReactEl)

  ;; likely going to be recursive/reused, so we need to be able to name them
  ;; i.e. projections need to be first class

  (:: UserContext {:username :first-name :last-name})

  (:: (render-author {:user {:username :first-name :last-name}}) (ReactEl a))

  (def (render-author {:user {username first-name last-name}})
    (div {:classes #{}}
         ["Written by @" username]))

  (:: (render-post {:username :first-name :last-name}) (ReactEl a))

  ;; more types
  {:user {:posts [{:post-id :title}]}}
  {:post {:user {:user-id :first-name :last-name}}}

  (def (post-data! post-id)
    (track! (?> db! :?posts (?get post-id) (?with {:user-id :title :content}))))

  (def (render-post post-id)
    (case (post-data! post-id)
      (:Just {user post})
      (div {}
           [(render-author user)
            (render-post post)])

      :Null
      (div {} "ohno")))

  (with-fx [(def (post-data! post-id)
              (:Just {:user-id (uuid "c66")}))

            (def (user-data! user-id)
              (:Just ))]
    (render-post post-id))

  (def (user-full-name {first-name last-name})
    (str first-name " " last-name))
#+END_SRC

** Project II
How about if project takes the same form as destructuring?


#+BEGIN_SRC clojure
  ;; ok, a summary
  ;; spec-keywords stay, as before
  (:: :user-id UUID)
  (:: :first-name Str)
  (:: :last-name Str)
  (:: :email Str)

  ;; composites - sets/vectors as before, records are specified as defaults
  (:: :address {:address1 :?address2 :region :city :postal-code})
  (:: :user {:user-id :address})

  ;; specify exact requirements in function declarations
  (:: (say-hi {:user}))

  ;; override with parens (nested, too)
  (:: (say-hi {(:user {:first-name :email (:address {:postal-code})})}))

  ;; destructure with those same parens
  (def (say-hi {(:user {first-name email address })})
    )

  ;; polymorphism:
  ;; keywords - suffix with `.`
  (:: :a.Ok a)

  ;; function declarations:
  (:: a.zero a)
  (:: (a.count a) Int)
  (:: (f.fmap (f a) ((Fn a) b)) (f b))

  ;; instance definitions
  (def Int.zero 0)

  (def (. [a] (count coll))
    ...)

  (def (. Tree (fmap tree f)))

  (def (Tree.fmap tree f)
    (case tree
      (:Node left val right) (:Node (fmap left f) (f val) (fmap right f))
      :Leaf :Leaf))

  (:: (! (print! Str)) Void)
#+END_SRC
