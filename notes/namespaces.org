* namespace as a compilation unit?
let's say we did top-level form as a compilation unit. what happens to changes
in type? we wouldn't want to not be able to change a type because something else
depended on it. (it probably needs to warn, sure)

so we have two (three?) passes:
- analysis pass - grabs hold of all the dependency information, what vars will be present
  this is only a top-level pass - doesn't need to worry about

- compilation/emission pass - compiles and emits.

- linking? if we do namespace-at-a-time compilation, we could link all the
  global vars at the top level within the namespace, and share them. effects and
  typeclasses still need to be passed though as individual args, though

#+BEGIN_SRC clojure
  (ns foo
    {:referring {(for-syntax bar)}})

  (def-for-syntax
    (def (foo ...)
      ...)
    )

  ;; macros are implicitly for syntax
  (defmacro (with-foo ...)
    ...)
#+END_SRC

* immutable namespaces?

benefits of immutable namespaces?
- means that the system continues to behave as it did
- avoids the problem of closed-over vs var-referenced values
- in a typed environment, need to be clear about what happens when you change the type of a callee

trade-offs
- more complex?
- have to reload the system to see changes?
