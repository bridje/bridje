* Environments
- we've got to respond to parse requests, essentially given a context and a source
- source potentially has multiple forms - requires, aliases, values and namespaces

previously I've wanted an 'immutable runtime environment' - why?
- largely because of the issues within Clojure with consistency of redefined functions
  - particularly, eval a function, eval another function that depends on
  - more important because it's a typed language - incompatible change to the type of a fn mean re-compile
  - other typed langs (Java, Kotlin, Haskell) are re-compile the world when a function changes
  - difference here is that we're REPL based, so there's the expectation that we don't need a build
  - deleting functions, too
  - it'll help that we're compiling at the namespace level, that'll get a decent chunk
  - GHCi is the closest they come to a REPL - let bindings in that REPL don't get updated when a dependent updates
  - so can we make namespaces behave in the same way?
  - or we can re-compile on-demand
    - i.e. we leave the bulk of the system to behave in the same way
    - values (i.e. closures) continue to behave in the same way for their lifetimes
    - as soon as we call a function that relies on an out-of-date namespace, we re-compile
  - let's give the user fine-grained control over contexts - we shouldn't re-use them

Macros
#+begin_src clojure
  (defn fn-in-this-ns []
    )

  (defmacro foo [a b]
    `(fn-in-this-ns a))
#+end_src

- resolution of syntax quotes within macros - Clojure fully qualifies the names within a syntax-quote - why?
- if the var is in the same namespace as the macro, we want to ensure that the symbol resolves to the correct var, when the macro is evaluated within a different namespace
- so this implies the macro is run within the namespace its declared in, but it then returns a form that has to be analysed within the namespace it's called from
- so we do need fully-qualified resolution - we have that with the resolver, though
- problem is that the Java interop (currently) can update NSEnvs outside of the current NS
- so we can either:
  - move all the Java interop to the top of the namespace (and hence create the NSEnv before we start the current NS)
  - make the Java interop within the current NS
    - means that these would be accessible as vars to other namespaces
- let's move all the Java interop to the top of the namespace
