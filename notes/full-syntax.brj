(ns full-syntax
  {:import {f com.foo
            b com.bar}
   :refer {com.foo #{my-fn my-other-fn :kw}}})

;;;; Primitives

true, false

"Hello"

4, -2
1.0, -155.34
42N
12.4M

;;;; Defining vars

(: foo Int)
(def foo 42)

(: (foo Int) Int)

(def (foo x)
  (+ x 10))

;;;; Basic colls

[1 2 3]
#{1 2 3}

(: (foo [Int]) Int)
(: (foo #{Int}) Int)

;;;; Macros
(defmacro (if-not p t e)
  `(if ~p ~e ~t))

;;;; Record keys

(: :age Int)

;; unqualified keys with `::` (opposite to Clojure)
{:age 10, ::unq "hello"}

;;;; Polymorphic record keys

(: [a] :anything #{a})

;;;; Record types
(: (foo {:name :age}) Str)
(: (foo {:name :age (& r)}) {(& r)})

;;;; Variants

(: (:AnInt Int))
(: :JustAVariant)

(:AnInt 42)
:JustAVariant

;;;; Polymorphic variants

(: [a] (:Ok a))

(: [a b] (:Mapper (Fn [a] b)))

;;;; Variant types
(: (:Composite (+ :AnInt :JustAVariant)))

(: [a] (:Maybe (:Ok a) :Nil))

;;;; Methods

(: [a] .m0 a)
(: [a] (.m+ a a) a)
(: [a] .m1 a)
(: [a] (.m* a a) a)

(def [Int] .m0 0)
(def [Int] (.m+ l r)
  (+ l r))

(: #{(m0 a) (m+ a)} (reduce [a]) a)
(def (reduce coll)
  ...)

(: [o a b] (.xform o a) [b])

(: [a b] (:Mapper (Fn [a] b)))

(def [(:Mapper a b) a b] (.xform (:Mapper f) el)
  [(f el)])

;;;; Effects

(: [o] (.log o Str) Unit)

;; definition of the default effect
(def [!] (log _ s)
  )

(: #{(.log !)} (log-my-thing Str) Unit)

(def (log-my-thing s)
  (.log ! s))

(: :MyLogger)

(:.log :MyLogger)

(def (.log :MyLogger)
  )

;; TODO first-class handlers?
;; we need to specify the method that we're implementing, and the implementation
;; implementation could be explicit, or by deferring to an object that already has the implementation

;; whatever we override, we're going to need to do it with _instances_ of the type
;; edge cases.
;; for effects, we know it's one object that's going to be passed in - does that mean we can't then make effects of methods that accept that type more than once?
;; what we're implicitly passing through is one of the parameters to the effect, implying that all the other parameters must be passed by the caller
;; so that does pretty much imply that the parameter has to be the whole of the type, and that the type can't exist elsewhere in the signature
;; and possibly that there can't be any other type parameters?
;; so it really is a special case of typeclasses (which is fine)
;; at which point, specifying the object itself is sufficient to determine the implementation, which opens up the syntax somewhat

(with-fx {.log :MyLogger
          .log (fn [this s]
                 )}
  ...)

(with-fx [(def [!] (log ! s)
            )
          (def [Int] m0 0)]
  )

;;;; Null:

(: (foo (Maybe Int))
   (Maybe Int))

(def (foo n)
  (case (:?maybe-k m)
    nil 0
    v v))

(def (foo i)
  (if-nn i
    (-> i (keep-when even?))
    0))

(when-nn n
  )

(nn-> ...)

(when-nil n
  )

;;;; Mutability: just use refs

(: :foo (Mut Int))

;;;; Coroutines

;; (not actually `with-suspend`, just `suspend`, but indentation)

(: (foo Int) (Suspend Int))

(: (suspend* (Fn r Unit) (Suspend r)))

(def (foo x)
  (with-suspend [k]
    (k 5)))

(with-async
  )

;;;; Interop:

;; JS - how do we access polyglot from Bridje?
;; polyglot bindings are deliberately treated differently to host

(ns foo
  {:java {LL (java.util.LinkedList
              (: ))}
   :poly {js }
   :import {LL (java java.util.LinkedList
                     (: (new ) (LL e))
                     (: (.add LL e)))
            foo com.foo
            js (poly "js"
                     (: bar Int)
                     (def bar "42")
                     (: ))}})

(LL/new ...)

;;;; Destructuring: TODO
