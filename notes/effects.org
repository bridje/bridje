* implementation of effects/typeclasses
Would need building up on every call, though.

typeclass instances - legitimately, could be a different object each time. let's
get as close as we can to invokevirtual? will likely only be a few types per
function call.

effects, not so much. could be a large number of effects, and not likely to
differ from call to call. can we reuse a large proportion of them?

** Java solution
- namespace -> class
- ~defx~ -> interface in final field
- referred namespace -> class in final field
- typeclasses - similar - interface implicitly passed to function.

so, working backwards, the clojure equivalent is closing over the context.

context can be a type for each namespace, containing the other namespaces we
depend on, and implementations of the effects

decisions for globals and effects

options:
- namespace containing functions:
  - globals are late-bound vars at the top of the namespace
  - effects?

- whole namespace as a value
  - close over mutable globals
  - close over effects

#+BEGIN_SRC clojure
  (deftype ConsoleEffect [print! read-line!])

  (->ConsoleEffect (fn print! [])
                   (fn read-line! []))

  (deftype MyNamespace [foo1 foo2])

  (fn [env]
    (->MyNamespace ...))

  (fn [env]
    (->ConsoleEffect (...)))
#+END_SRC
