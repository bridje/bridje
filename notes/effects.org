#+begin_src clojure
  (def foo
    (fn [fn]
      (println! "Hello, " fn)))

  (def (foo fn)
    (println! "Hello, " fn))
#+end_src

what's the difference between these two?
we say that fns take the effects from the lexical environment, but with the former case, there's nowhere for them to pull the effects from
when we resolve foo, do we need to supply the effects?
do we need to change how we think about how effects are passed?

do we need to have effect maps only being passed as part of functions?
as far as global vars are concerned, by the time it gets into the env it'll be the function at the top level
but the above example shows we can essentially run any code at the top level, at compile time

what would we do outside of Bridje?
java static - can't mock that
haskell - can't do effects at the top level - has to be part of main
  - I reckon this'll be closer to what we end up with

so we're back on the action bollocks again.

in Haskell, it'd be the inner function that's effectful - you essentially have to specify the IO behaviour in order to use it.
you essentially supply all the arguments, then, finally, you get back an action
let's say this was CPS - the monad takes a function as the last argument - it's this last application that runs the action
it means the behaviour /has/ to be supplied by the immediate caller, or delegated
if we're doing structured concurrency, do a lot of the problems of dynamically scoping effects go away?
- function types would then specify all the effects that they'd cause if they're called
- top level definitions still couldn't have effects - but I don't think that'd matter
- does mean that we need to have type-params for effects too though? as in, the function takes on the effects of the functions passed to it?
- in the mappings, we'll need to have a mapping for effect type params through to effects and more type params

although I don't think it's /just/ structured concurrency, it's also laziness - functions being returned that will lose their context.
can we still say that functions pick up the context of where they're created?
- not if we want effects to work in top-level forms - somehow something's different about them.
- so we have effect fns that are created as part of top-level forms, and effect fns that are created in calls? do they behave differently? /can/ they behave differently?
  - I don't see why not - within a fn the effects can be supplied from the context; top level we can prevent effects entirely if need be (or, at least, non-defaulted effects)
  - OT: what do we want to do about top-level effects, outside of a function? run the side effect every time it runs?

so, three states - top-level, outside fn, top-level first fn, and inner fn?
- top-level, effect local is null, we disallow effects
- top-level fn sets the effect local
  - does this need to be passed regardless of whether the function is effectful? any way we can elide it if we don't need it?
  - the top level expr isn't necessarily a fnexpr, so we can't automagically set it
  - but we can see what type it is and pass null if it's not required
  - we could also 'just' pass through the current effect local, which we know won't be used
  - this is far easier - we know that all top-level fns have an effect local, even if they're not used?
    - any way for a top-level fn to /not/ have an effect local?
    - if we're outside a fn, and we try to call a top-level fn - we know the top-level fn can't depend on any non-defaulted effects (but we still need to pass them)
      - or do we? if we say that default effects aren't in the map (i.e. we pass an empty dynamic object at the top level) then passing empty map is fine
      - and this way, we can statically link to default effects, which'll likely be much more efficient for the normal case.
  - who's responsible for checking for effects?
    - analyser can check for effects at the top-level - there won't be an effect-local set and we know we're referencing a global-var
- if the effect local is already set, we don't need to set it again

this is valid Bridje, but the effects are out of kilter
#+begin_src clojure
  (def foo
    (let [bar! (fn []
                 (println! "Hello"))]
      (fn []
        (bar!))))
#+end_src

which implies that we can only really allow effects in top-level fns in tail position, which is a weird constraint
particularly, we want the tail-position fn to take its effects from the dynamic context, but the let-bound fn to take them from the lexical context
we need a better solution to top-level effects

does everything need to be dynamic context?
- only impacts if a closure escapes its with-fx - likely?
- means that we're moving closer to a effects-paper-style effect type-system - means that effects are realised when they're called?
- need to make sure that effects are passed over thread boundaries
- interop-boundaries? we can't expect interop callers to call the function with an effects param
- which then seems like we have to bundle effectful fns up with the effects as and when the function object's created
  - except the top-level, tail position ones, those we want to take on the dynamic context. gah.
- is it going to be awkward to debug if the effects are executed a long way away from where they're overridden?
- can we take two sources of overrides? one from dynamic, one from lexical?
  - which would we prioritise? presumably dynamic, they're 'closer'
  - what about if one override is an interceptor, calls through to the existing effect?

maybe we do dynamic, but allow binding effects lexically as a special case?
- interop functions could then be specified to take functions with zero effects - could we type-check that?
  - if we didn't, we'd be looking at a runtime error - an effect without a default impl may not have been specified
  - would we need to be able to specify that a function takes a pure function?
    - but that function could be nested down within a data structure
- could we auto-bind lexically over an interop point?
  - we certainly know when a fn's been called over interop vs being called from Bridje
  - it may well be a relatively slow call anyway

maybe we do it lexically, but dynamically (i.e. top-level tail-position) is the special case?
- i.e. all functions record the lexical effects
- some are passed effects at top level - these take preference over whatever they were given lexically?
- type checking that?
  - function would need to know what effects they call, so that they can be overridden
  - there'd be effects from the expression, and effects from within the function
  - 'foo', in the example above, wouldn't have any dynamic effects, would have println as a lexical effect
  - we couldn't 'just' remove the dynamic effects from the lexical set - could be in both
  - lexical effects would come from non-tail, dynamic effects from tail
  - fnexprs would convert all lexical effects into dynamic effects
  - but then we could have =(let [foo (fn [] (println! "Hello"))] foo)= which wouldn't work this way. sad.
    - in this case, we'd say that foo, because it's in the lexical position, takes the effects of the lexical context
  - maybe we do make an explicit exception for that top-level first tail position function?

if we were to give the user explicit choice over it, what would this mean?
- this is essentially the bound-fn approach?
- maybe we make 'with-fx' behave that way?
  - 'with-fx' can return anything - we'd want lex-fx to capture it for, well, the whole returned DS?
  - but the whole returned DS could be nested - this'd be problematic

what about if lex were the default, but we give users the ability to make certain effects dynamic?
- would mean that we'd need to special case the top-level tail-position
- but the vast majority of the time, this'll be handled by the =(def (foo x y) ...)= sugar any way
- and if you do faff about with =(def foo (let [f (fn [x y] ...)] foo))=, it's up to you to Deal With Itâ„¢.
- does mean we need a new special form, dyn-fx? can we wrap any form with this?
  - optimisations-wise, we'd want to wrap an fn directly, so that the effects can be passed as first arg, single call?
  - so looks like we'd want a =dyn-fn= special form, behaves like =fn=
  - and that way, the =def= sugar only needs to return its body as a DynFnExpr, and it /should/ get handled throughout.
- the type system would have to be able to handle both dynamic and lexical effects, but I don't think that scares me?
  - we already handle lex-fx, adding dyn-fx would mean that functions would also need the more traditional algebraic effects semantics
  - worth the hassle? haha
- the only thing I don't like about this solution is that it has two different concepts, would rather just have one.
  - but I think this is the best of the 'two-concept' systems
  - it does mean that the entire system needs to handle lex and dyn fx - with the 'tail position' hack, would it limit the impact?
  - i.e. it's not possible to pass dyn-fx fns to other fns - we resolve the fx when we resolve the GV.
  - which is something we could enforce anyway
- so there's a spectrum of solutions here, from least to most permissive
  - least permissive - only available through =def= sugar?
    - in this case, we'd put the effects on the GV, most likely
  - in the middle is the 'top-level, tail position' hack
  - most permissive - =dyn-fn= special form?
    - in this case, each fntype would (potentially) have a set of fx
