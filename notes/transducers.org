* Transducers
** Round 1 - explicit state
#+BEGIN_SRC clojure
  (defadt (ReduceState s b)
    (More s b)
    (Done s b))

  (defadt (StepResult a)
    None
    (Single a)
    (Multiple [a]))

  (defadt (Reducer s a b)
    (Reducer s
             (Fn [s a] (ReduceState s b))
             (Maybe (Fn [s] b))))



  (:: (reduce [a]
              (∀ #{s} (Reducer s a (StepResult b)))
              (∀ #{s} (Reducer s b c)))
      c)

  (def (reduce coll xf rf)
    (loop [xf-state ]))

  (defmacro (xf* &forms)
    )

  (def id-xf
    (Reducer Unit (fn (step s el) (More s [el])) Nothing))

  (def (map f)
    (Reducer Unit

             (fn (step s el)
               (More s (Single (f el))))

             Nothing))

  (def (filter p)
    (Reducer Unit

             (fn (step s el)
               (More s (if (p el) (Single el) None)))

             Nothing))

  (def (mapcat f)
    (Reducer Unit
             (fn (step s el)
               (More s (Multiple (f el))))
             Nothing))

  (def (take n)
    (Reducer n
             (fn (step s el)
               (if (pos? s)
                 (More (dec n) (Single el))
                 (Done 0 None)))
             Nothing))

  (def (drop n)
    (Reducer n
             (fn (step n el)
               (if (pos? n)
                 (More (dec n) None)
                 (More 0 (Single el))))
             Nothing))

  (def (partition-all n)
    (Reducer []
             (fn (step coll el)
               (let ((coll (conj coll el)))
                 (if (= n (count coll))
                   (More [] (Single coll))
                   (More coll None))))

             (Just (fn (complete s acc)
                     (conj acc s)))))
#+END_SRC
** Round 2 - state effect
#+BEGIN_SRC clojure
  (defeffect (Mut s)
    (:: (mv! a) (MutVar s a))
    (:: (deref! (MutVar s a)) a)
    (:: (reset! (MutVar s a) a) Unit))

  (:: (swap! (MutVar s a) (Fn [a] a)) a)
  (:: (run! a) a) ; removes Mut effects

  (:: (append! (TransientVec s a) a) (TransientVec s a))
  (:: (transient-vec! [a]) (TransientVec s a))
  (:: (persistent-vec! (TransientVec s a)) [a])

  (def (->vec)
    (let [!s (transient-vec [])]
      (Reducer (fn (step el)
                 (append! !s el))
               (Just (fn (complete)
                       (persistent-vec! !s))))))

  (def (map f)
    (Transducer (fn (step el)
                  (rf (f el)))

                Nothing))

  (def (take n)
    (let [!n (mv! n)]
      (Transducer (fn (step el)
                    (when (pos? (swap! !n dec))
                      (reduced!))

                    (rf el))

                  Nothing)))
#+END_SRC
