* Transducers
** Round 1 - explicit state
#+BEGIN_SRC clojure
  (defadt (ReduceState s b)
    (More s b)
    (Done s b))

  (defadt (StepResult a)
    None
    (Single a)
    (Multiple [a]))

  (defadt (Reducer s a b)
    (Reducer s
             (Fn [s a] (ReduceState s b))
             (Maybe (Fn [s] b))))



  (:: (reduce [a]
              (∀ #{s} (Reducer s a (StepResult b)))
              (∀ #{s} (Reducer s b c)))
      c)

  (def (reduce coll xf rf)
    (loop [xf-state ]))

  (defmacro (xf* &forms)
    )

  (def id-xf
    (Reducer Unit (fn (step s el) (More s [el])) Nothing))

  (def (map f)
    (Reducer Unit

             (fn (step s el)
               (More s (Single (f el))))

             Nothing))

  (def (filter p)
    (Reducer Unit

             (fn (step s el)
               (More s (if (p el) (Single el) None)))

             Nothing))

  (def (mapcat f)
    (Reducer Unit
             (fn (step s el)
               (More s (Multiple (f el))))
             Nothing))

  (def (take n)
    (Reducer n
             (fn (step s el)
               (if (pos? s)
                 (More (dec n) (Single el))
                 (Done 0 None)))
             Nothing))

  (def (drop n)
    (Reducer n
             (fn (step n el)
               (if (pos? n)
                 (More (dec n) None)
                 (More 0 (Single el))))
             Nothing))

  (def (partition-all n)
    (Reducer []
             (fn (step coll el)
               (let ((coll (conj coll el)))
                 (if (= n (count coll))
                   (More [] (Single coll))
                   (More coll None))))

             (Just (fn (complete s acc)
                     (conj acc s)))))
#+END_SRC
** Round 2 - state effect
#+BEGIN_SRC clojure
  (defx (Mut s)
    (:: (mv! a) (MutVar s a))
    (:: (deref! (MutVar s a)) a)
    (:: (reset! (MutVar s a) a) Unit))

  (:: (swap! (MutVar s a) (Fn [a] a)) a)
  (:: (run! a) a) ; removes Mut effects

  (:: (append! (TransientVec s a) a) (TransientVec s a))
  (:: (transient-vec! [a]) (TransientVec s a))
  (:: (persistent-vec! (TransientVec s a)) [a])

  (def (->vec)
    (let [!s (mv! (transient-vec []))]
      (Reducer (fn (step el)
                 (swap! !s (->% (append! el))))
               (fn (complete)
                 (persistent-vec! (deref! !s))))))

  (def id
    (Transducer (fn (step el)
                  (t/rf1 true el))
                Nothing))

  (def (transduce coll xf rf)
    )

  (def (reduce coll rf)
    )

  (def (map f)
    (Transducer (fn (step el)
                  (t/rf1 true (f el)))

                Nothing))

  (def (filter f)
    (Transducer (fn (step el)
                  (if (f el)
                    (t/rf1 true el)
                    (t/rf0 true)))

                Nothing))

  (def (mapcat f)
    (Transducer (fn (step el)
                  (t/rf* true (f el)))))

  (def (take n)
    (let [!n (mv! n)]
      (Transducer (fn (step el)
                    (t/rf1 (pos? (swap! !n dec)) el))

                  Nothing)))

  (def (drop n)
    (let [!n (mv! n)]
      (Transducer (fn (step el)
                    (if (pos? (swap! !n dec))
                      (t/rf0 true)
                      (t/rf1 true el)))
                  Nothing)))

  (def (take-while f)
    (Transducer (fn (step el)
                  (if (f el)
                    (t/rf1 true el)
                    (t/rf0 false)))
                Nothing))

  (def (partition-all n)
    (let [!coll (mv! (transient-vec! []))]
      (Transducer (fn (step el)
                    (swap! !coll (->% (append! el)))
                    (if (= n (count! !coll))
                      (let [coll (persistent-vec! (deref! !coll))]
                        (reset! !coll (transient-vec! []))
                        (t/rf1 true coll))
                      (t/rf0 true)))

                  (Just (fn (complete)
                          (if (pos? (count! !coll))
                            (t/rf1 true el)
                            (t/rf0 true)))))))
#+END_SRC


everything created under the same Mut effect cannot escape the effect

in Haskell, it works because it's runST that creates an instance of all the
mutable vars - whereas we create them all imperatively (for all intents and
purposes).

Haskell's ST monad doesn't work across threads, though, although they

can we get `run` to do a similar thing?

might mean a double deref... maybe we do need a threadlocal for this one?

alternatively, we just 'unsafe' the whole lot. which does mean we don't have to do higher-kinded types (yet)
does mean that we need to support it forever, though

** Plan of action:

*** DONE =do= form
*** DONE changes to interop
*** TODO 'throw'/'try/catch'
*** DONE varargs in macros
*** TODO Basic classes
*** TODO Destructuring
*** TODO mutually recursive definitions
*** TODO mutable state effect
*** TODO higher-ranked types :/
*** TODO =if-seq= macro
