* Polymorphism implementation
- Need to have a value to pass to the GlobalVarExpr when we emit it
- Don't really want to make it a partial application (though we could)
- GlobalVarExpr needs to have a series of pre-args, maybe?
- implementing with dictionary passing (in the absence of other ideas), so GlobalVars need to store what order those args
  are passed in - unless we pass an object to any var that has type constraints, same as we do with effects
- build up that dictionary at the CallExpr emission, same as we do with effects?
- could be fun with higher-ranked types - we're going to need to 'keep some back' so that the callee can provide
  implementations.
- FnExpr - need to separate out the constraints at that point - these constraints are dynamic (unlike effects that are
  static)
- one option is to pass the first part of a dictionary
- partially applying these functions? would need to doubly-partially apply them in the higher-ranked case (although this would be a simple wrapper node that merged the two dictionaries)
- this being the case, maybe we should partially apply effects too?
  - can we make effects work as a special case of typeclasses?
  - typeclasses with zero type params?
  - static vs dynamic would be interesting - don't think the typeclass system would behave this way by default -
    especially with the behaviour around function boundaries.
  - but we could certainly partially apply those functions, set up the effect read var into a materialized frame
  - we could certainly make any function that had either effects or type constraints be partially applied, take effects
    first, constraints second
  - maybe even the same dict for both?
  - we'd want to move the wrapping definition as high as possible within the function

back to the simple implementation
- emitter needs to know, for any fn, what poly constraints they are
- also still need to decide what form those poly constraints take
- easy case, defn, looks at the overall type of the expression
- anonymous polymorphic fn - counts whatever's passed to it (say)
- so let's say each polymorphic call carries around an id of the poly call, which then gets unified, same way as params/return-type
- sgna mean that one fnexprs aren't data classes - or perhaps they can be, if the parameter isn't required through the primary constructor
- call expressions are also going to need information about the functions they're calling - do we need to pass poly params?
- we can probably keep this as part of the analyser, or maybe a separate pass afterwards
- do we need to touch the emitter at all? or can this all be done as part of the analyser?
  - we can certainly deal with the effects system (mostly) as part of the analyser, would be surprised if we couldn't do the same with polys
  - let's make it a separate pass, after the analyser?
  - it's certainly going to need to be after the type-checker - that's what decides what implementations we use for each callsite
  - let's refactor how the effects work as part of this, it'll be a similar pass

things to consider:
- when we get down to the actual effect call, we need to pass through all the effects except the current implementation, so that the handler can call through to the inner handler
- if the effectful var's resolved outside of a callexpr, who supplies the effects?
  - seems like it should be wherever it's resolved
  - how do we then resolve the inner handler's effects?
  - unless they're done within the with-fx call. that would make a lot of sense.
    - at that point, we don't need to care about passing through the inner handlers - they'll already have them
    - fair bit of this is passed dynamically, though
  - optimisation: we'll want to hoist these out of the innermost loops, though, doesn't make sense to keep calling these intermediate functions
- they're carried down as lexical scope - is there an easier way?

- option A: do we 'just' pass the lexical scope down regardless, make it a proper dynamic scope?
  - this means that closures just ignore their dynamic scope (fine)
  - overhead to passing on every call?
- option B: how can we efficiently write closures in Graal?
  - will likely need to create an object,
  - unless we can materialise the frame
  - we'll likely need this solution when we come to polys, regardless?
    - in this case though, we need it - we may well pass a poly to something more specific
    - e.g. passing count to a (Fn #{Str} Int)
- option C: hoist /all/ the effectful vars
  - going to be way more vars that depend on effects than actual effects, though
