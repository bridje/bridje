* Polymorphism implementation
- Need to have a value to pass to the GlobalVarExpr when we emit it
- Don't really want to make it a partial application (though we could)
- GlobalVarExpr needs to have a series of pre-args, maybe?
- implementing with dictionary passing (in the absence of other ideas), so GlobalVars need to store what order those args
  are passed in - unless we pass an object to any var that has type constraints, same as we do with effects
- build up that dictionary at the CallExpr emission, same as we do with effects?
- could be fun with higher-ranked types - we're going to need to 'keep some back' so that the callee can provide
  implementations.
- FnExpr - need to separate out the constraints at that point - these constraints are dynamic (unlike effects that are
  static)
- one option is to pass the first part of a dictionary
- partially applying these functions? would need to doubly-partially apply them in the higher-ranked case (although this would be a simple wrapper node that merged the two dictionaries)
- this being the case, maybe we should partially apply effects too?
  - can we make effects work as a special case of typeclasses?
  - typeclasses with zero type params?
  - static vs dynamic would be interesting - don't think the typeclass system would behave this way by default -
    especially with the behaviour around function boundaries.
  - but we could certainly partially apply those functions, set up the effect read var into a materialized frame
  - we could certainly make any function that had either effects or type constraints be partially applied, take effects
    first, constraints second
  - maybe even the same dict for both?
  - we'd want to move the wrapping definition as high as possible within the function

back to the simple implementation
- emitter needs to know, for any fn, what poly constraints they are
- also still need to decide what form those poly constraints take
- easy case, defn, looks at the overall type of the expression
- anonymous polymorphic fn - counts whatever's passed to it (say)
- so let's say each polymorphic call carries around an id of the poly call, which then gets unified, same way as params/return-type
- sgna mean that one fnexprs aren't data classes - or perhaps they can be, if the parameter isn't required through the primary constructor
- call expressions are also going to need information about the functions they're calling - do we need to pass poly params?
- we can probably keep this as part of the analyser, or maybe a separate pass afterwards
- do we need to touch the emitter at all? or can this all be done as part of the analyser?
  - we can certainly deal with the effects system (mostly) as part of the analyser, would be surprised if we couldn't do the same with polys
  - let's make it a separate pass, after the analyser?
  - it's certainly going to need to be after the type-checker - that's what decides what implementations we use for each callsite
  - let's refactor how the effects work as part of this, it'll be a similar pass

implementation-wise:
- implement 'cata' on expressions
